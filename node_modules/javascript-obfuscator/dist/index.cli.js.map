{"version":3,"sources":["webpack://JavaScriptObfuscator/webpack/bootstrap","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/interopRequireDefault\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/classCallCheck\"","webpack://JavaScriptObfuscator/external \"inversify\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/createClass\"","webpack://JavaScriptObfuscator/external \"tslib\"","webpack://JavaScriptObfuscator/./src/container/ServiceIdentifiers.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/getPrototypeOf\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/inherits\"","webpack://JavaScriptObfuscator/./src/node/NodeGuards.ts","webpack://JavaScriptObfuscator/./src/decorators/Initializable.ts","webpack://JavaScriptObfuscator/./src/node/NodeUtils.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/TransformationStage.ts","webpack://JavaScriptObfuscator/./src/node-transformers/AbstractNodeTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeFactory.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNode.ts","webpack://JavaScriptObfuscator/external \"estraverse\"","webpack://JavaScriptObfuscator/./src/node/NodeMetadata.ts","webpack://JavaScriptObfuscator/external \"string-template\"","webpack://JavaScriptObfuscator/./src/enums/node/NodeType.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/container/InversifyContainerFacade.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ControlFlowCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/ObfuscationTarget.ts","webpack://JavaScriptObfuscator/./src/node/NodeStatementUtils.ts","webpack://JavaScriptObfuscator/./src/node/NodeAppender.ts","webpack://JavaScriptObfuscator/./src/enums/event-emitters/ObfuscationEvent.ts","webpack://JavaScriptObfuscator/./src/node/NodeLexicalScopeUtils.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/toConsumableArray\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/NodeTransformer.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/slicedToArray\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNode.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorFacade.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/utils/Utils.ts","webpack://JavaScriptObfuscator/./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/enums/source-map/SourceMapMode.ts","webpack://JavaScriptObfuscator/./src/enums/StringArrayEncoding.ts","webpack://JavaScriptObfuscator/./src/options/presets/NoCustomNodes.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/get\"","webpack://JavaScriptObfuscator/./src/utils/NumberUtils.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"escodegen-wallaby\"","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableNoEvalTemplate.ts","webpack://JavaScriptObfuscator/./src/options/presets/Default.ts","webpack://JavaScriptObfuscator/./src/enums/analyzers/stack-trace-analyzer/CalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/typeof\"","webpack://JavaScriptObfuscator/external \"espree\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AbstractPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/storages/MapStorage.ts","webpack://JavaScriptObfuscator/./src/utils/RandomGenerator.ts","webpack://JavaScriptObfuscator/external \"chalk\"","webpack://JavaScriptObfuscator/external \"reflect-metadata\"","webpack://JavaScriptObfuscator/./src/logger/Logger.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingPrefix.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/construct\"","webpack://JavaScriptObfuscator/./src/container/modules/analyzers/AnalyzersModule.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/StackTraceAnalyzer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ConvertingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate1.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate2.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack://JavaScriptObfuscator/./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack://JavaScriptObfuscator/./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/SingleNodeCallControllerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack://JavaScriptObfuscator/./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack://JavaScriptObfuscator/./src/templates/AtobTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/Rc4Template.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/FinalizingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/generators/GeneratorsModule.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ClassDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ImportDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeBlockLexicalScopeUtils.ts","webpack://JavaScriptObfuscator/./src/container/modules/options/OptionsModule.ts","webpack://JavaScriptObfuscator/./src/options/Options.ts","webpack://JavaScriptObfuscator/external \"class-validator\"","webpack://JavaScriptObfuscator/./src/options/ValidationErrorsFormatter.ts","webpack://JavaScriptObfuscator/./src/options/OptionsNormalizer.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DomainLockRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/InputFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SelfDefendingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayEncodingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayThresholdRule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/PreparingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CommentsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/EvaCallExpressionTransformer.ts","webpack://JavaScriptObfuscator/external \"js-string-escape\"","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/MetadataTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/VariablePreserveTransformer.ts","webpack://JavaScriptObfuscator/./src/container/modules/storages/StoragesModule.ts","webpack://JavaScriptObfuscator/./src/storages/control-flow/ControlFlowStorage.ts","webpack://JavaScriptObfuscator/./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack://JavaScriptObfuscator/./src/storages/string-array/StringArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/ArrayStorage.ts","webpack://JavaScriptObfuscator/./src/container/modules/utils/UtilsModule.ts","webpack://JavaScriptObfuscator/./src/utils/ArrayUtils.ts","webpack://JavaScriptObfuscator/./src/utils/CryptUtils.ts","webpack://JavaScriptObfuscator/external \"md5\"","webpack://JavaScriptObfuscator/external \"chance\"","webpack://JavaScriptObfuscator/./src/utils/EscapeSequenceEncoder.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscator.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingMessage.ts","webpack://JavaScriptObfuscator/./src/EspreeFacade.ts","webpack://JavaScriptObfuscator/./src/event-emitters/ObfuscationEventEmitter.ts","webpack://JavaScriptObfuscator/external \"eventemitter3\"","webpack://JavaScriptObfuscator/./src/source-code/ObfuscatedCode.ts","webpack://JavaScriptObfuscator/./src/source-code/SourceCode.ts","webpack://JavaScriptObfuscator/./src/node-transformers/TransformersRunner.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/VisitorDirection.ts","webpack://JavaScriptObfuscator/./src/cli/JavaScriptObfuscatorCLI.ts","webpack://JavaScriptObfuscator/external \"path\"","webpack://JavaScriptObfuscator/external \"fs\"","webpack://JavaScriptObfuscator/./index.cli.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorCLIFacade.ts","webpack://JavaScriptObfuscator/external \"commander\"","webpack://JavaScriptObfuscator/./src/cli/sanitizers/ArraySanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/BooleanSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/IdentifierNamesGeneratorSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/ObfuscatingTargetSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/SourceMapModeSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/StringArrayEncodingSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/utils/CLIUtils.ts","webpack://JavaScriptObfuscator/external \"mkdirp\"","webpack://JavaScriptObfuscator/./src/cli/utils sync","webpack://JavaScriptObfuscator/./src/cli/utils/SourceCodeReader.ts","webpack://JavaScriptObfuscator/external \"multimatch\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ServiceIdentifiers","NodeGuards","node","type","NodeType","ArrayPattern","ArrowFunctionExpression","AssignmentPattern","AwaitExpression","BlockStatement","BreakStatement","CallExpression","CatchClause","ClassDeclaration","ContinueStatement","ExportNamedDeclaration","ExpressionStatement","isFunctionDeclarationNode","isFunctionExpressionNode","isArrowFunctionExpressionNode","FunctionDeclaration","FunctionExpression","Identifier","ImportDeclaration","ImportSpecifier","parentNode","parentNodeIsLabeledStatementNode","isLabeledStatementNode","label","parentNodeIsContinueStatementNode","isContinueStatementNode","parentNodeIsBreakStatementNode","isBreakStatementNode","LabeledStatement","Literal","MemberExpression","MethodDefinition","undefined","isProgramNode","isFunctionNode","isNodeWithLexicalScope","isBlockStatementNode","nodesWithLexicalStatements","includes","isSwitchCaseNode","Boolean","leadingComments","trailingComments","ObjectPattern","ObjectExpression","Program","Property","isPropertyNode","computed","isMemberExpressionNode","isMethodDefinitionNode","isIdentifierNode","parentNodeIsPropertyNode","parentNodeIsMemberExpressionNode","parentNodeIsMethodDefinitionNode","isLabelIdentifierNode","RestElement","ReturnStatement","Super","SwitchCase","TaggedTemplateExpression","TemplateLiteral","UnaryExpression","directive","VariableDeclaration","VariableDeclarator","WhileStatement","defaultDescriptor","configurable","initializedTargetMetadataKey","initializablePropertiesSetMetadataKey","wrappedMethodsSetMetadataKey","constructorMethodName","initializeTargetMetadata","metadataKey","metadataValue","target","Reflect","hasMetadata","defineMetadata","initializeMethodName","decoratorName","keys","this","propertyKey","initializeMethod","Error","Set","ownPropertyNames","getOwnPropertyNames","prohibitedPropertyNames","forEach","propertyName","initializablePropertiesSet","getMetadata","wrappedMethodsSet","has","methodDescriptor","getOwnPropertyDescriptor","originalMethod","apply","arguments","add","wrapTargetMethodsInInitializedCheck","result","wrapInitializeMethodInInitializeCheck","initializablePropertyMetadataKey","toString","propertyDescriptor","set","newVal","wrapInitializableProperty","NodeUtils","literalNode","content","raw","precedence","escodegen","Precedence","Primary","astTree","parentizeAst","cloneRecursive","code","structure","espree","parse","sourceType","estraverse","replace","enter","parentizeNode","isLiteralNode","addXVerbatimPropertyTo","NodeMetadata","ignoredNode","body","reduce","generate","sourceMapWithCode","unaryExpressionNode","isUnaryExpressionNode","argument","getUnaryExpressionArgumentNode","copy","clonedValue","RegExp","Array","isArray","map","TransformationStage","AbstractNodeTransformer","randomGenerator","options","injectable","inject","IRandomGenerator","IOptions","NodeFactory","metadata","elements","ArrayExpression","operator","left","right","AssignmentExpression","BinaryExpression","callee","args","expression","functionName","params","id","identifierNode","generator","test","consequent","alternate","IfStatement","LogicalExpression","kind","static","properties","method","shorthand","discriminant","cases","SwitchStatement","prefix","argumentExpr","UpdateExpression","declarations","init","AbstractCustomNode","identifierNamesGeneratorFactory","cachedNode","identifierNamesGenerator","getNodeStructure","getRandomGenerator","pickone","globalVariableTemplateFunctions","GlobalVariableTemplate1","GlobalVariableTemplate2","Factory__IIdentifierNamesGenerator","assign","IdentifierObfuscatingReplacer","InversifyContainerFacade","container","Container","serviceIdentifier","named","getNamed","sourceCode","sourceMap","ISourceCode","toDynamicValue","SourceCode","inSingletonScope","TInputOptions","ILogger","to","Logger","IJavaScriptObfuscator","JavaScriptObfuscator","ITransformersRunner","TransformersRunner","IObfuscatedCode","ObfuscatedCode","Factory__IObfuscatedCode","toFactory","context","obfuscatedCodeAsString","sourceMapAsString","obfuscatedCode","initialize","IObfuscationEventEmitter","ObfuscationEventEmitter","load","analyzersModule","controlFlowTransformersModule","convertingTransformersModule","customNodesModule","finalizingTransformersModule","generatorsModule","nodeTransformersModule","obfuscatingTransformersModule","optionsModule","preparingTransformersModule","storagesModule","utilsModule","unbindAll","bindingName","cache","Map","dependencies","cachedDependencies","dependency","index","constructor","ControlFlowCustomNode","ObfuscationTarget","NodeStatementUtils","getParentNodesWithStatementsRecursive","statement","getSiblingStatementByOffset","ReferenceError","isNodeWithStatements","getRootStatementOfNode","getScopeOfNode","maxSize","Infinity","nodesWithStatements","depth","length","isNodeWithLexicalScopeStatements","push","offset","scopeNode","scopeBody","indexInScope","indexOf","NodeAppender","nodeWithStatements","statements","parentizeScopeStatementsBeforeAppend","setScopeStatements","getScopeStatements","stackTraceData","bodyStatements","targetBlockScope","getOptimalBlockScope","prepend","deep","firstCall","stackTrace","indexInScopeStatement","insertAtIndex","slice","ObfuscationEvent","NodeLexicalScopeUtils","getLexicalScopesRecursive","nodesWithLexicalScope","NodeTransformer","CustomNode","JavaScriptObfuscatorFacade","inputOptions","inversifyContainerFacade","javaScriptObfuscator","obfuscate","unload","version","AbstractCustomNodeGroup","appendEvent","customNodes","customNodeName","callback","customNode","stackTraceLength","getRandomInteger","Math","max","round","Utils","url","split","hexadecimalPrefix","IdentifierNamesGenerator","SourceMapMode","StringArrayEncoding","NO_ADDITIONAL_NODES_PRESET","freeze","compact","controlFlowFlattening","controlFlowFlatteningThreshold","deadCodeInjection","deadCodeInjectionThreshold","debugProtection","debugProtectionInterval","disableConsoleOutput","domainLock","exclude","HexadecimalIdentifierNamesGenerator","identifiersPrefix","inputFileName","log","renameGlobals","reservedNames","reservedStrings","rotateStringArray","seed","selfDefending","sourceMapBaseUrl","sourceMapFileName","sourceMapMode","Separate","stringArray","stringArrayEncoding","stringArrayThreshold","Browser","transformObjectKeys","unicodeEscapeSequence","NumberUtils","dec","number","AbstractObfuscatingReplacer","AbstractCalleeDataExtractor","AbstractControlFlowReplacer","controlFlowCustomNodeFactory","replacerDataByControlFlowStorageId","controlFlowStorage","replacerId","usingExistingIdentifierChance","controlFlowStorageId","getStorageId","storageKeysById","getStorageKeysByIdForCurrentStorage","storageKeysForCurrentId","getMathRandom","storageKey","generateStorageKey","getRandomString","getStorage","identifierDataByControlFlowStorageId","Factory__IControlFlowCustomNode","DEFAULT_PRESET","config","CalleeDataExtractor","ControlFlowReplacer","ExpressionWithOperatorControlFlowReplacer","leftExpression","rightExpression","controlFlowStorageCallCustomNode","ExpressionWithOperatorControlFlowStorageCallNode","statementNode","getNode","isExpressionStatementNode","DeadCodeInjectionCustomNode","PropertiesExtractor","AbstractPropertiesExtractor","cachedHostNodesWithStatementsMap","cachedHostStatementsMap","memberExpressionHostNode","propertiesLength","expressionStatements","removablePropertyIds","propertyValue","isProhibitedPattern","propertyKeyName","getPropertyNodeKeyName","memberExpressionProperty","memberExpressionNode","expressionStatementNode","assignmentExpressionNode","isObjectExpressionNode","transformObjectExpressionNode","objectExpressionNode","filter","extractPropertiesToExpressionStatements","hostStatement","getHostStatement","hostNodeWithStatements","getHostNodeWithStatements","filterExtractedObjectExpressionProperties","insertAfter","propertyNode","propertyKeyNode","isObjectPatternNode","isArrayPatternNode","isAssignmentPatternNode","isRestElementNode","CustomNodeGroup","AbstractIdentifierNamesGenerator","preservedNames","notReservedName","some","reservedName","exec","LiteralObfuscatingReplacer","ObfuscatingGuard","ConditionalCommentObfuscatingGuard","obfuscationAllowedForCurrentNode","obfuscationAllowedForNextNode","isNodeWithComments","checkComments","comments","commentsLength","obfuscationAllowed","comment","obfuscationEnableCommentRegExp","obfuscationDisableCommentRegExp","MapStorage","storage","storageId","size","mergeId","initializable","postConstruct","RandomGenerator","min","md5Hash","floor","random","Chance","getSourceCode","Number","integer","pool","randomGeneratorPool","string","loggingMessage","colorInfo","LoggingPrefix","Base","colorSuccess","colorWarn","loggingLevelColor","loggingPrefix","processedMessage","console","cyan","green","yellow","ContainerModule","IStackTraceAnalyzer","StackTraceAnalyzer","ICalleeDataExtractor","FunctionDeclarationCalleeDataExtractor","whenTargetNamed","FunctionExpressionCalleeDataExtractor","ObjectExpressionCalleeDataExtractor","Factory__ICalleeDataExtractor","getCacheFactory","blockScopeBody","calleeBlockStatement","getCalleeBlockStatement","getParentNodeWithStatements","targetNode","traverse","VisitorOption","Break","isVariableDeclaratorNode","objectMembersCallsChain","createObjectMembersCallsChain","functionExpressionName","currentChain","memberExpression","unshift","objectName","shift","findCalleeBlockStatement","objectExpressionProperties","nextItemInCallsChain","isValidTargetPropertyNode","isTargetPropertyNodeWithIdentifierKey","isTargetPropertyNodeWithLiteralKey","calleeDataExtractorFactory","analyzeRecursive","limitIndex","getLimitIndex","blockScopeBodyLength","blockScopeBodyNode","isCallExpressionNode","Skip","analyzeCallExpressionNode","callExpressionNode","calleeDataExtractorsList","calleeDataExtractorName","calleeData","extract","lastIndex","limitThresholdActivationIndex","limitThresholdActivationLength","limitThreshold","INodeTransformer","BlockStatementControlFlowTransformer","DeadCodeInjectionTransformer","FunctionControlFlowTransformer","IControlFlowReplacer","BinaryExpressionControlFlowReplacer","CallExpressionControlFlowReplacer","LogicalExpressionControlFlowReplacer","StringLiteralControlFlowReplacer","Factory__IControlFlowReplacer","binaryExpressionNode","binaryExpressionFunctionCustomNode","BinaryExpressionFunctionNode","insertCustomNodeToControlFlowStorage","getControlFlowStorageCallNode","arrayUtils","transformationStage","ControlFlowFlattening","leave","transformNode","blockStatementNode","canTransformBlockStatementNode","blockStatementBody","originalKeys","createWithRange","shuffledKeys","shuffle","originalKeysIndexesInShuffledArray","blockStatementControlFlowFlatteningCustomNode","BlockStatementControlFlowFlatteningNode","newBlockStatementNode","isBreakOrContinueStatement","isVariableDeclarationWithLetOrConstKind","isVariableDeclarationNode","isClassDeclaration","isClassDeclarationNode","canTransform","isWhileStatementNode","isProhibitedStatementNode","IArrayUtils","String","callExpressionFunctionCustomNode","CallExpressionFunctionNode","expressionArguments","CallExpressionControlFlowStorageCallNode","deadCodeInjectionCustomNodeFactory","transformersRunner","deadCodeInjectionRootAstHostNodeSet","collectedBlockStatements","collectedBlockStatementsTotalLength","DeadCodeInjection","analyzeNode","Finalizing","isDeadCodeInjectionRootAstHostNode","restoreNode","programNode","clonedBlockStatementNode","clone","isValidCollectedBlockStatementNode","transformedBlockStatementNode","makeClonedBlockStatementNodeUnique","minCollectedBlockStatementsCount","isValidWrappedBlockStatementNode","maxInteger","randomIndex","randomBlockStatementNode","splice","replaceBlockStatementNode","deadCodeInjectionRootAstHostNode","hostNodeFirstStatement","hostNode","functionExpressionNode","transform","transformersToRenameBlockScopeIdentifiers","Obfuscating","functionDeclarationNode","deadCodeInjectionRootAstHostNodeName","blockStatementDeadCodeInjectionCustomNode","BlockStatementDeadCodeInjectionNode","isAwaitExpressionNode","isSuperNode","slicedBody","hostBlockStatementNode","functionDeclarationName","isScopeHoistedFunctionDeclaration","nestedBlockStatementsCount","isValidBlockStatementNode","maxNestedBlockStatementsCount","isProhibitedNodeInsideCollectedBlockStatement","isScopeHoistingFunctionDeclaration","CatchClauseTransformer","ClassDeclarationTransformer","FunctionDeclarationTransformer","FunctionTransformer","LabeledStatementTransformer","VariableDeclarationTransformer","Factory__IDeadCodeInjectionCustomNode","controlFlowStorageFactory","controlFlowReplacerFactory","controlFlowData","visitedFunctionNodes","hostNodesWithControlFlowNode","functionNode","getHostNode","getControlFlowStorage","transformFunctionBody","getLength","controlFlowStorageCustomNode","ControlFlowStorageNode","hostControlFlowStorage","mergeWith","functionNodeBody","blockScopesOfNode","getParentNodesWithStatements","pop","hostNodeSearchMinDepth","hostNodeSearchMaxDepth","isIgnoredNode","isVisitedFunctionNode","controlFlowReplacersMap","controlFlowReplacerName","Factory__TControlFlowStorage","logicalExpressionNode","checkForProhibitedExpressions","logicalExpressionFunctionCustomNode","LogicalExpressionFunctionNode","expressionNode","nodeForCheck","literalFunctionCustomNode","StringLiteralNode","StringLiteralControlFlowStorageCallNode","MemberExpressionTransformer","MethodDefinitionTransformer","ObjectExpressionKeysTransformer","ObjectExpressionTransformer","TemplateLiteralTransformer","IPropertiesExtractor","AssignmentExpressionPropertiesExtractor","VariableDeclaratorPropertiesExtractor","Factory__IPropertiesExtractor","hostParentNode","leftNode","isProhibitedHostParent","Converting","methodDefinitionNode","ignoredNames","propertiesExtractorFactory","propertiesExtractorName","propertiesExtractorsMap","escapeSequenceEncoder","transformComputedProperty","transformBaseProperty","getPropertyKeyValue","inputValue","encode","IEscapeSequenceEncoder","isValidTemplateLiteralNode","templateLiteralNode","transformedNode","templateLiteralExpressions","expressions","nodes","quasis","templateElement","cooked","isLiteralNodeWithStringValue","root","isTemplateLiteralNode","isTaggedTemplateExpressionNode","isProhibitedObjectExpressionNode","variableDeclaratorNode","hostVariableDeclarator","getHostVariableDeclaratorNode","getHostVariableDeclarationNode","indexOfDeclarator","declaratorsAfterCurrentDeclarator","variableDeclarator","ICustomNode","ConsoleOutputDisableExpressionNode","DebugProtectionFunctionCallNode","DebugProtectionFunctionIntervalNode","DebugProtectionFunctionNode","DomainLockNode","NodeCallsControllerFunctionNode","SelfDefendingUnicodeNode","StringArrayCallsWrapper","StringArrayNode","StringArrayRotateFunctionNode","Newable__ICustomNode","toConstructor","ICustomNodeGroup","ConsoleOutputCustomNodeGroup","DebugProtectionCustomNodeGroup","DomainLockCustomNodeGroup","SelfDefendingCustomNodeGroup","StringArrayCustomNodeGroup","Factory__ICustomNode","getFactory","getConstructorFactory","Factory__ICustomNodeGroup","customNodeFactory","BeforeObfuscation","randomStackTraceIndex","getRandomStackTraceIndex","appendCustomNodeIfExist","appendToOptimalBlockScope","targetNodeWithStatements","callsControllerFunctionName","consoleOutputDisableExpressionNode","nodeCallsControllerFunctionNode","append","programBodyLength","debugProtectionFunctionName","debugProtectionFunctionNode","debugProtectionFunctionCallNode","debugProtectionFunctionIntervalNode","domainLockNode","AfterObfuscation","selfDefendingUnicodeNode","stringArrayStorage","stringArrayRotateValue","stringArrayNode","stringArrayCallsWrapper","stringArrayRotateFunctionNode","stringArrayName","stringArrayCallsWrapperName","TStringArrayStorage","returnStatementNode","controllerIdentifierName","indexIdentifierName","variableDeclarationNode","join","whileStatementNode","switchStatementNode","updateExpressionNode","isReturnStatementNode","continueStatement","switchCaseNode","breakStatement","random1","random2","leftString","rightString","ifStatementNode","controlFlowStorageName","controlFlowStorageKey","calleeIdentifier","argumentsLength","propertyNodes","from","convertCodeToStructure","getTemplate","globalVariableTemplate","BrowserNoEval","getGlobalVariableTemplate","GlobalVariableNoEvalTemplate","ConsoleOutputDisableExpressionTemplate","consoleLogDisableFunctionName","singleNodeCallControllerFunctionName","DebugProtectionFunctionCallTemplate","DebugProtectionFunctionIntervalTemplate","debuggerTemplate","DebuggerTemplate","DebuggerTemplateNoEval","DebugProtectionFunctionTemplate","cryptUtils","domainsString","hideString","hiddenDomainsString","diff","DomainLockNodeTemplate","domainLockFunctionName","domains","ICryptUtils","leftValue","rightValue","SingleNodeCallControllerTemplate","getObfuscatedCode","SelfDefendingTemplate","selfDefendingFunctionName","decodeNodeTemplate","getDecodeStringArrayTemplate","StringArrayCallsWrapperTemplate","atobPolyfill","AtobTemplate","decodeStringArrayTemplate","selfDefendingCode","Rc4","StringArrayRc4DecodeNodeTemplate","rc4Polyfill","Rc4Template","Base64","StringArrayBase64DecodeNodeTemplate","rc4BytesIdentifier","statesIdentifier","newStateIdentifier","firstStateIdentifier","secondStateIdentifier","checkStateIdentifier","runStateIdentifier","getStateIdentifier","stateResultIdentifier","initializedIdentifier","base64DecodeFunctionIdentifier","dataIdentifier","rc4Identifier","onceIdentifier","rotateArray","StringArrayTemplate","timesName","whileFunctionName","StringArrayRotateFunctionTemplate","toHex","literalValue","IIdentifierNamesGenerator","MangledIdentifierNamesGenerator","cachedIdentifierNamesGenerator","randomVariableNameSet","nameLength","randomInteger","hexadecimalNumber","prefixLength","baseNameLength","baseIdentifierNameLength","baseIdentifierName","substr","identifierName","previousMangledName","initMangledNameCharacter","generateNewMangledName","mangledName","nameSequence","zeroSequence","num","repeat","character","charAt","indexInSequence","substring","newMangledName","isValidIdentifierName","Factory__INodeTransformer","ImportDeclarationTransformer","LiteralTransformer","IObfuscatingReplacer","BooleanLiteralObfuscatingReplacer","NumberLiteralObfuscatingReplacer","StringLiteralObfuscatingReplacer","IIdentifierObfuscatingReplacer","BaseIdentifierObfuscatingReplacer","Factory__IObfuscatingReplacer","Factory__IIdentifierObfuscatingReplacer","blockScopesMap","nodeValue","lexicalScopeNode","namesMap","nodeName","isReservedName","generateWithPrefix","preserveName","getTrueUnaryExpressionNode","getFalseUnaryExpressionNode","arrayExpressionNode","identifierObfuscatingReplacerFactory","identifierObfuscatingReplacer","isCatchClauseNode","catchClauseNode","getLexicalScope","storeCatchClauseParam","replaceCatchClauseParam","param","storeLocalName","isReplaceableIdentifierNode","newIdentifierName","renamedIdentifier","replaceableIdentifiers","isExportNamedDeclarationNode","classDeclarationNode","isGlobalDeclaration","storeClassName","replaceScopeCachedIdentifiers","replaceScopeIdentifiers","storeGlobalName","cachedReplaceableIdentifiers","cachedReplaceableIdentifierLength","replaceableIdentifier","newReplaceableIdentifier","storedReplaceableIdentifiersNamesMap","isRenamedIdentifier","storedReplaceableIdentifiers","storeFunctionName","storeFunctionParams","replaceFunctionParams","getLexicalScopes","visitor","isProhibitedIdentifierOfPropertyNode","paramsNode","ignoredIdentifierNamesSet","isProhibitedIdentifierOfShorthandPropertyNode","isGlobalFunctionDeclarationIdentifier","isImportDeclarationNode","importDeclarationNode","storeImportSpecifierNames","specifiers","importSpecifierNode","isProhibitedImportSpecifierNode","local","isImportSpecifierNode","imported","labeledStatementNode","storeLabeledStatementName","replaceLabeledStatementName","newIdentifier","literalObfuscatingReplacerFactory","isReplacedLiteral","isProhibitedNode","newLiteralNode","numberLiteralCache","rawValue","isCeil","nodesCache","stringLiteralHexadecimalIndexCache","rc4Keys","rc4KeyLength","rc4KeysCount","isReservedString","replaceWithReservedLiteralNode","useStringArray","canUseStringArray","cacheKey","resultNode","replaceWithStringArrayCallNode","replaceWithLiteralNode","minimumLengthForStringArray","stringArrayStorageLength","fromCache","hexadecimalRawIndex","hexadecimalIndex","encodedValue","btoa","rc4","getEncodedValue","escapedValue","stringArrayStorageCallsWrapperName","getStringArrayHexadecimalIndex","callExpressionArgs","getHexadecimalLiteralNode","getRc4KeyLiteralNode","stringArrayIdentifierNode","reservedString","hexadecimalLiteralNode","replacedLiteral","rc4KeyLiteralNode","NodeBlockLexicalScopeUtils","storeVariableNames","traverseDeclarationIdentifiers","cachedReplaceableIdentifiersNamesMap","identifierNames","declarationNode","isNodeWithBlockLexicalScope","Options","IOptionsNormalizer","OptionsNormalizer","optionsNormalizer","errors","validateSync","validatorOptions","ValidationErrorsFormatter","format","normalize","validationError","IsBoolean","IsNumber","Min","Max","IsArray","ArrayUnique","IsString","each","IsIn","ValidateIf","IsUrl","require_protocol","require_tld","require_valid_protocol","Inline","Node","errorMessages","error","formatWithNestedConstraints","constraints","rootError","nestedErrors","constraint","normalizedOptions","normalizerRules","normalizerRule","ControlFlowFlatteningThresholdRule","DeadCodeInjectionRule","DeadCodeInjectionThresholdRule","DomainLockRule","InputFileNameRule","SelfDefendingRule","SourceMapBaseUrlRule","SourceMapFileNameRule","StringArrayRule","StringArrayEncodingRule","StringArrayThresholdRule","normalizedDomains","domain","extractDomainFrom","endsWith","CommentsTransformer","CustomNodesTransformer","EvalCallExpressionTransformer","MetadataTransformer","ObfuscatingGuardsTransformer","ParentificationTransformer","INodeGuard","BlackListObfuscatingGuard","BlackListNodeGuard","ConditionalCommentNodeGuard","Factory__INodeGuard","VariablePreserveTransformer","blackListGuardsLength","blackListGuards","isUseStrictOperator","Initializing","transformComments","commentIdx","findIndex","range","reverse","preservedWords","preservedWord","isConditionalComment","stackTraceAnalyzer","obfuscationEventEmitter","customNodeGroupStorage","Preparing","appendCustomNodesBeforeObfuscation","appendCustomNodesAfterObfuscation","analyze","customNodeGroup","once","getAppendEvent","appendCustomNodes","emit","TCustomNodeGroupStorage","evalRootAstHostNodeSet","isEvalRootAstHostNode","callExpressionFirstArgument","ast","evalString","extractEvalStringFromCallExpressionArgument","evalRootAstHostNode","targetAst","convertStructureToCode","extractEvalStringFromLiteralNode","extractEvalStringFromTemplateLiteralNode","obfuscatingGuardFactory","obfuscatingGuards","obfuscatingGuardsList","every","nodeGuard","check","CustomNodeGroupStorage","StringArrayStorage","Newable__TControlFlowStorage","ControlFlowStorage","customNodeGroupFactory","customNodeGroupsList","customNodeGroupName","baseStringArrayName","stringArrayNameLength","baseStringArrayCallsWrapperName","rotationValue","rotate","ArrayStorage","storageLength","ArrayUtils","CryptUtils","EscapeSequenceEncoder","array","times","temp","newArray","shuffledArray","j","output","encodeURIComponent","match","p1","fromCharCode","parseInt","block","charCode","idx","charCodeAt","str","randomStringDiff","randomStringDiffArray","s1","s2","i1","i2","randomMerge","x","y","stringsCache","encodeAllSymbols","template","replaceRegExp","escapeSequenceRegExp","regExp","obfuscatedCodeFactory","logger","timeStart","Date","now","info","LoggingMessage","Version","ObfuscationStarted","RandomGeneratorSeed","getSeed","parseCode","obfuscatedAstTree","transformAstTree","generatorOutput","generateCode","obfuscationTime","success","ObfuscationCompleted","EspreeFacade","espreeParseOptions","runTransformationStage","warn","EmptySourceCode","escodegenParams","sourceContent","transformersList","ecmaVersion","loc","verbatim","input","sourceTypeLength","sourceTypes","parseType","processParsingError","message","line","lineNumber","column","inputConfig","errorMessage","position","errorLine","startErrorIndex","nearestSymbolsCount","endErrorIndex","formattedPointer","colorError","formattedCodeSlice","red","decorate","correctObfuscatedCode","sourceMapUrl","sourceMappingUrl","nodeTransformerFactory","nodeTransformers","enterVisitors","leaveVisitors","nodeTransformersLength","getVisitor","mergeVisitorsForDirection","VisitorDirection","Enter","Leave","visitors","direction","visitorsLength","visitorFunction","visitorResult","isNode","JavaScriptObfuscatorCLI","argv","rawArguments","inputPath","path","commands","commander","Command","configureCommands","configureHelp","inputCLIOptions","opts","outputHelp","sourceCodeData","SourceCodeReader","readSourceCode","processSourceCodeData","filterOptions","configFilePath","configFileLocation","resolve","configFileOptions","CLIUtils","getUserConfig","basename","usage","option","BooleanSanitizer","parseFloat","ArraySanitizer","IdentifierNamesGeneratorSanitizer","SourceMapModeSanitizer","StringArrayEncodingSanitizer","ObfuscationTargetSanitizer","on","outputPath","filePath","outputCodePath","getOutputCodePath","processSourceCode","sourceCodeIndex","buildOptions","baseIdentifiersPrefix","processSourceCodeWithSourceMap","processSourceCodeWithoutSourceMap","filteredOptions","writeFile","outputSourceMapPath","getOutputSourceMapPath","getSourceMap","encoding","obfuscatedFilePrefix","JavaScriptObfuscatorCLIFacade","javaScriptObfuscatorCLI","run","SyntaxError","trim","lastIndexOf","configPath","data","mkdirp","sync","dirname","fs","writeFileSync","webpackEmptyContext","req","e","isFilePath","isValidFile","readFile","isDirectoryPath","isValidDirectory","readDirectoryRecursive","availableFilePaths","availableInputExtensions","extension","directoryPath","fileData","readdirSync","fileName","logFilePath","readFileSync","isExcludedPath","extname","excludePatterns","isExcludedFilePathByGlobPattern","isExcludedFilePathByInclusion","excludePattern","statSync","isDirectory","isFile","normalizedFilePath","CLI"],"mappings":"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","file":"index.cli.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 203);\n","module.exports = require(\"@babel/runtime/helpers/interopRequireDefault\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"inversify\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"tslib\");","export enum ServiceIdentifiers {\n    Factory__ICalleeDataExtractor = 'Factory<ICalleeDataExtractor>',\n    Factory__IControlFlowCustomNode = 'Factory<IControlFlowCustomNode>',\n    Factory__IControlFlowReplacer = 'Factory<IControlFlowReplacer>',\n    Factory__ICustomNode = 'Factory<ICustomNode>',\n    Factory__ICustomNodeGroup = 'Factory<ICustomNodeGroup>',\n    Factory__IDeadCodeInjectionCustomNode = 'Factory<IDeadCodeInjectionCustomNode>',\n    Factory__IIdentifierNamesGenerator = 'Factory<IIdentifierNamesGenerator>',\n    Factory__IIdentifierObfuscatingReplacer = 'Factory<IIdentifierObfuscatingReplacer>',\n    Factory__INodeGuard = 'Factory<INodeGuard>',\n    Factory__INodeTransformer = 'Factory<INodeTransformer[]>',\n    Factory__IObfuscatedCode = 'Factory<IObfuscatedCode>',\n    Factory__IObfuscatingReplacer = 'Factory<IObfuscatingReplacer>',\n    Factory__IPropertiesExtractor = 'Factory<IPropertiesExtractor>',\n    Factory__TControlFlowStorage = 'Factory<TControlFlowStorage>',\n    IArrayUtils = 'IArrayUtils',\n    ICalleeDataExtractor = 'ICalleeDataExtractor',\n    ICryptUtils = 'ICryptUtils',\n    ICustomNode = 'ICustomNode',\n    ICustomNodeGroup = 'ICustomNodeGroup',\n    IControlFlowReplacer = 'IControlFlowReplacer',\n    IEscapeSequenceEncoder = 'IEscapeSequenceEncoder',\n    IIdentifierNamesGenerator = 'IIdentifierNamesGenerator',\n    IIdentifierObfuscatingReplacer = 'IIdentifierObfuscatingReplacer',\n    IJavaScriptObfuscator = 'IJavaScriptObfuscator',\n    ILogger = 'ILogger',\n    INodeGuard = 'INodeGuard',\n    INodeTransformer = 'INodeTransformer',\n    IObfuscationEventEmitter = 'IObfuscationEventEmitter',\n    IObfuscatedCode = 'IObfuscatedCode',\n    IOptions = 'IOptions',\n    IOptionsNormalizer = 'IOptionsNormalizer',\n    IObfuscatingReplacer = 'IObfuscatingReplacer',\n    IPropertiesExtractor = 'IPropertiesExtractor',\n    IRandomGenerator = 'IRandomGenerator',\n    ISourceCode = 'ISourceCode',\n    ISourceMapCorrector = 'ISourceMapCorrector',\n    IStackTraceAnalyzer = 'IStackTraceAnalyzer',\n    ITransformersRunner = 'ITransformersRunner',\n    Newable__ICustomNode = 'Newable<ICustomNode>',\n    Newable__TControlFlowStorage = 'Newable<TControlFlowStorage>',\n    TCustomNodeGroupStorage = 'TCustomNodeGroupStorage',\n    TInputOptions = 'TInputOptions',\n    TStringArrayStorage = 'TStringArrayStorage'\n}\n","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeGuards {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithLexicalStatements: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n    ];\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrayPatternNode (node: ESTree.Node): node is ESTree.ArrayPattern {\n        return node.type === NodeType.ArrayPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAwaitExpressionNode (node: ESTree.Node): node is ESTree.AwaitExpression {\n        return node.type === NodeType.AwaitExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isClassDeclarationNode (node: ESTree.Node): node is ESTree.ClassDeclaration {\n        return node.type === NodeType.ClassDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExportNamedDeclarationNode (node: ESTree.Node): node is ESTree.ExportNamedDeclaration {\n        return node.type === NodeType.ExportNamedDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionNode (node: ESTree.Node): node is ESTree.Function {\n        return NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (node: ESTree.Node): node is ESTree.FunctionDeclaration {\n        return node.type === NodeType.FunctionDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDeclarationNode (node: ESTree.Node): node is ESTree.ImportDeclaration {\n        return node.type === NodeType.ImportDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportSpecifierNode (node: ESTree.Node): node is ESTree.ImportSpecifier {\n        return node.type === NodeType.ImportSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = NodeGuards.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = NodeGuards.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = NodeGuards.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param {Object} object\n     * @returns {boolean}\n     */\n    public static isNode (object: Object & { type?: string }): object is ESTree.Node {\n        return object && !object.type !== undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isProgramNode(node) || NodeGuards.isFunctionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithBlockLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isNodeWithLexicalScope(node) || NodeGuards.isBlockStatementNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScopeStatements (\n        node: ESTree.Node,\n        parentNode: ESTree.Node\n    ): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || (NodeGuards.isBlockStatementNode(node) && NodeGuards.nodesWithLexicalStatements.includes(parentNode.type));\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithStatements (node: ESTree.Node): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || NodeGuards.isBlockStatementNode(node)\n            || NodeGuards.isSwitchCaseNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithComments (node: ESTree.Node): node is ESTree.Node {\n        return Boolean(node.leadingComments) || Boolean(node.trailingComments);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsPropertyNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isPropertyNode(parentNode)\n            && !parentNode.computed\n            && parentNode.key === node;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsMemberExpressionNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return (\n            NodeGuards.isMemberExpressionNode(parentNode)\n            && !parentNode.computed\n            && parentNode.property === node\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsMethodDefinitionNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isMethodDefinitionNode(parentNode)\n            && !parentNode.computed;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isIdentifierNode(node)\n            && !NodeGuards.parentNodeIsPropertyNode(node, parentNode)\n            && !NodeGuards.parentNodeIsMemberExpressionNode(node, parentNode)\n            && !NodeGuards.parentNodeIsMethodDefinitionNode(node, parentNode)\n            && !NodeGuards.isLabelIdentifierNode(node, parentNode);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isRestElementNode (node: ESTree.Node): node is ESTree.RestElement {\n        return node.type === NodeType.RestElement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isReturnStatementNode (node: ESTree.Node): node is ESTree.ReturnStatement {\n        return node.type === NodeType.ReturnStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSuperNode (node: ESTree.Node): node is ESTree.Super {\n        return node.type === NodeType.Super;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSwitchCaseNode (node: ESTree.Node): node is ESTree.SwitchCase {\n        return node.type === NodeType.SwitchCase;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTaggedTemplateExpressionNode (node: ESTree.Node): node is ESTree.TaggedTemplateExpression {\n        return node.type === NodeType.TaggedTemplateExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUseStrictOperator (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement && node.directive === 'use strict';\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isWhileStatementNode (node: ESTree.Node): node is ESTree.WhileStatement {\n        return node.type === NodeType.WhileStatement;\n    }\n}\n","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\nconst defaultDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true\n};\nconst initializedTargetMetadataKey: string = '_initialized';\nconst initializablePropertiesSetMetadataKey: string = '_initializablePropertiesSet';\nconst wrappedMethodsSetMetadataKey: string = '_wrappedMethodsSet';\nconst constructorMethodName: string = 'constructor';\n\n/**\n * @param {string} initializeMethodName\n * @returns {(target: IInitializable, propertyKey: (string | symbol)) => any}\n */\nexport function initializable (\n    initializeMethodName: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor => {\n        const initializeMethod: Function = target[initializeMethodName];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n            throw new Error(`\\`${initializeMethodName}\\` method with initialization logic not ` +\n                `found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodName}\\` method`);\n        }\n\n        /**\n         * Stage #1: initialize target metadata\n         */\n        initializeTargetMetadata(initializedTargetMetadataKey, false, target);\n        initializeTargetMetadata(initializablePropertiesSetMetadataKey, new Set(), target);\n        initializeTargetMetadata(wrappedMethodsSetMetadataKey, new Set(), target);\n\n        /**\n         * Stage #2: wrap target methods\n         */\n        wrapTargetMethodsInInitializedCheck(target, initializeMethodName);\n        wrapInitializeMethodInInitializeCheck(target, initializeMethodName, propertyKey);\n\n        /**\n         * Stage #3: wrap target properties\n         */\n        return wrapInitializableProperty(target, propertyKey);\n    };\n}\n\n/**\n * @param {string} metadataKey\n * @param metadataValue\n * @param {IInitializable} target\n */\nfunction initializeTargetMetadata (metadataKey: string, metadataValue: any, target: IInitializable): void {\n    const hasInitializedMetadata: boolean = Reflect.hasMetadata(metadataKey, target);\n\n    if (!hasInitializedMetadata) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target);\n    }\n}\n\n/**\n * Wraps all target methods with additional logic that check that this methods will called after `initialize` method\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n */\nfunction wrapTargetMethodsInInitializedCheck (target: IInitializable, initializeMethodName: string): void {\n    const ownPropertyNames: string[] = Object.getOwnPropertyNames(target);\n    const prohibitedPropertyNames: string[] = [initializeMethodName, constructorMethodName];\n\n    ownPropertyNames.forEach((propertyName: string) => {\n        const initializablePropertiesSet: Set <string | symbol> = Reflect\n            .getMetadata(initializablePropertiesSetMetadataKey, target);\n        const wrappedMethodsSet: Set <string | symbol> = Reflect\n            .getMetadata(wrappedMethodsSetMetadataKey, target);\n\n        const isProhibitedPropertyName: boolean = prohibitedPropertyNames.includes(propertyName)\n            || initializablePropertiesSet.has(propertyName)\n            || wrappedMethodsSet.has(propertyName);\n\n        if (isProhibitedPropertyName) {\n            return;\n        }\n\n        const targetProperty: IInitializable[keyof IInitializable] = target[propertyName];\n\n        if (typeof targetProperty !== 'function') {\n            return;\n        }\n\n        const methodDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, propertyName) || defaultDescriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyName, {\n            ...methodDescriptor,\n            value: function (): void {\n                if (!Reflect.getMetadata(initializedTargetMetadataKey, this)) {\n                    throw new Error(`Class should be initialized with \\`${initializeMethodName}()\\` method`);\n                }\n\n                return originalMethod.apply(this, arguments);\n            }\n        });\n\n        wrappedMethodsSet.add(propertyName);\n    });\n}\n\n/**\n * Wraps `initialize` method with additional logic to check that `initialized` properties will set\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n * @param {string | symbol} propertyKey\n */\nfunction wrapInitializeMethodInInitializeCheck (\n    target: IInitializable,\n    initializeMethodName: string,\n    propertyKey: string | symbol\n): void {\n    const methodDescriptor: PropertyDescriptor = Object\n        .getOwnPropertyDescriptor(target, initializeMethodName) || defaultDescriptor;\n    const originalMethod: Function = methodDescriptor.value;\n\n    Object.defineProperty(target, initializeMethodName, {\n        ...methodDescriptor,\n        value: function (): typeof originalMethod {\n            /**\n             * should define metadata before `initialize` method call,\n             * because of cases when other methods will called inside `initialize` method\n             */\n            Reflect.defineMetadata(initializedTargetMetadataKey, true, this);\n\n            const result: typeof originalMethod = originalMethod.apply(this, arguments);\n\n            if (this[propertyKey]) {}\n\n            return result;\n        }\n    });\n}\n\n/**\n * Wraps initializable property in additional checks\n *\n * @param {IInitializable} target\n * @param {string | symbol} propertyKey\n * @returns {PropertyDescriptor}\n */\nfunction wrapInitializableProperty (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor {\n    const initializablePropertiesSet: Set <string | symbol> = Reflect\n        .getMetadata(initializablePropertiesSetMetadataKey, target);\n\n    initializablePropertiesSet.add(propertyKey);\n\n    const initializablePropertyMetadataKey: string = `_${propertyKey.toString()}`;\n    const propertyDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, initializablePropertyMetadataKey) || defaultDescriptor;\n\n    Object.defineProperty(target, propertyKey, {\n        ...propertyDescriptor,\n        get: function (): any {\n            if (this[initializablePropertyMetadataKey] === undefined) {\n                throw new Error(`Property \\`${propertyKey.toString()}\\` is not initialized! Initialize it first!`);\n            }\n\n            return this[initializablePropertyMetadataKey];\n        },\n        set: function (newVal: any): void {\n            this[initializablePropertyMetadataKey] = newVal;\n        }\n    });\n\n    return propertyDescriptor;\n}\n","import * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { NodeGuards } from './NodeGuards';\nimport { NodeMetadata } from './NodeMetadata';\n\nexport class NodeUtils {\n    /**\n     * @param {T} literalNode\n     * @returns {T}\n     */\n    public static addXVerbatimPropertyTo (literalNode: ESTree.Literal): ESTree.Literal {\n        literalNode['x-verbatim-property'] = {\n            content: literalNode.raw,\n            precedence: escodegen.Precedence.Primary\n        };\n\n        return literalNode;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static clone <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        return NodeUtils.parentizeAst(NodeUtils.cloneRecursive(astTree));\n    }\n\n    /**\n     * @param {string} code\n     * @returns {Statement[]}\n     */\n    public static convertCodeToStructure (code: string): ESTree.Statement[] {\n        const structure: ESTree.Program = espree.parse(code, { sourceType: 'script' });\n\n        estraverse.replace(structure, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node => {\n                NodeUtils.parentizeNode(node, parentNode);\n\n                if (NodeGuards.isLiteralNode(node)) {\n                    NodeUtils.addXVerbatimPropertyTo(node);\n                }\n\n                NodeMetadata.set(node, { ignoredNode: false });\n\n                return node;\n            }\n        });\n\n        return <ESTree.Statement[]>structure.body;\n    }\n\n    /**\n     * @param {NodeGuards[]} structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        return structure.reduce((code: string, node: ESTree.Node) => {\n            return code + escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        }, '');\n    }\n\n    /**\n     * @param {UnaryExpression} unaryExpressionNode\n     * @returns {NodeGuards}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (NodeGuards.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static parentizeAst <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            enter: NodeUtils.parentizeNode\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} node\n     * @param {Node} parentNode\n     * @returns {T}\n     */\n    public static parentizeNode <T extends ESTree.Node = ESTree.Node> (node: T, parentNode: ESTree.Node | null): T {\n        node.parentNode = parentNode || node;\n\n        return node;\n    }\n\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    private static cloneRecursive <T> (node: T): T {\n        if (node === null) {\n            return node;\n        }\n\n        const copy: Partial<T> = {};\n        const nodeKeys: (keyof T)[] = <(keyof T)[]>Object.keys(node);\n\n        nodeKeys\n            .forEach((property: keyof T) => {\n                if (property === 'parentNode') {\n                    return;\n                }\n\n                const value: T[keyof T] = node[property];\n\n                let clonedValue: T[keyof T] | T[keyof T][] | null;\n\n                if (value === null || value instanceof RegExp) {\n                    clonedValue = value;\n                } else if (Array.isArray(value)) {\n                    clonedValue = value.map(NodeUtils.cloneRecursive);\n                } else if (typeof value === 'object') {\n                    clonedValue = NodeUtils.cloneRecursive(value);\n                } else {\n                    clonedValue = value;\n                }\n\n                copy[property] = <T[keyof T]>clonedValue;\n            });\n\n        return <T>copy;\n    }\n}\n","export enum TransformationStage {\n    Initializing = 'Initializing',\n    Preparing = 'Preparing',\n    DeadCodeInjection = 'DeadCodeInjection',\n    ControlFlowFlattening = 'ControlFlowFlattening',\n    Converting = 'Converting',\n    Obfuscating = 'Obfuscating',\n    Finalizing = 'Finalizing'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public abstract getVisitor (transformationStage: TransformationStage): IVisitor | null;\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node | VisitorOption}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node | estraverse.VisitorOption;\n}\n","/* tslint:disable:max-file-line-count */\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeFactory {\n    /**\n     * @param {TStatement[]} body\n     * @returns {Program}\n     */\n    public static programNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} elements\n     * @returns {ArrayExpression}\n     */\n    public static arrayExpressionNode (\n        elements: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.ArrayExpression {\n        return {\n            type: NodeType.ArrayExpression,\n            elements,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {AssignmentOperator} operator\n     * @param {Pattern | MemberExpression} left\n     * @param {Expression} right\n     * @returns {AssignmentExpression}\n     */\n    public static assignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {BinaryExpression}\n     */\n    public static binaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Statement[]} body\n     * @returns {BlockStatement}\n     */\n    public static blockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {BreakStatement}\n     */\n    public static breakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        return {\n            type: NodeType.BreakStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} args\n     * @returns {CallExpression}\n     */\n    public static callExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {ContinueStatement}\n     */\n    public static continueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        return {\n            type: NodeType.ContinueStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} expression\n     * @returns {ExpressionStatement}\n     */\n    public static expressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} functionName\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionDeclaration}\n     */\n    public static functionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: NodeFactory.identifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionExpression}\n     */\n    public static functionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {BlockStatement} consequent\n     * @param {BlockStatement} alternate\n     * @returns {IfStatement}\n     */\n    public static ifStatementNode (\n        test: ESTree.Expression,\n        consequent: ESTree.BlockStatement,\n        alternate?: ESTree.BlockStatement\n    ): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            ...alternate && { alternate },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} name\n     * @returns {Identifier}\n     */\n    public static identifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {boolean | number | string} value\n     * @param {string} raw\n     * @returns {Literal}\n     */\n    public static literalNode (value: boolean | number | string, raw?: string): ESTree.Literal {\n        raw = raw !== undefined ? raw : `'${value}'`;\n\n        return {\n            type: NodeType.Literal,\n            value,\n            raw,\n            'x-verbatim-property': {\n                content: raw,\n                precedence: escodegen.Precedence.Primary\n            },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {LogicalExpression}\n     */\n    public static logicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression | Super} object\n     * @param {Expression} property\n     * @param {boolean} computed\n     * @returns {MemberExpression}\n     */\n    public static memberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {FunctionExpression} value\n     * @param {\"constructor\" | \"method\" | \"get\" | \"set\"} kind\n     * @param {boolean} computed\n     * @returns {MethodDefinition}\n     */\n    public static methodDefinitionNode (\n        key: ESTree.Expression,\n        value: ESTree.FunctionExpression,\n        kind: 'constructor' | 'method' | 'get' | 'set',\n        computed: boolean,\n    ): ESTree.MethodDefinition {\n        return {\n            type: NodeType.MethodDefinition,\n            key,\n            value,\n            kind,\n            computed,\n            static: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @returns {ObjectExpression}\n     */\n    public static objectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {Expression | Pattern} value\n     * @param {boolean} computed\n     * @returns {Property}\n     */\n    public static propertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} argument\n     * @returns {ReturnStatement}\n     */\n    public static returnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} discriminant\n     * @param {SwitchCase[]} cases\n     * @returns {SwitchStatement}\n     */\n    public static switchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement[]} consequent\n     * @returns {SwitchCase}\n     */\n    public static switchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UnaryOperator} operator\n     * @param {Expression} argument\n     * @param {true} prefix\n     * @returns {UnaryExpression}\n     */\n    public static unaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: true = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UpdateOperator} operator\n     * @param {Expression} argumentExpr\n     * @returns {UpdateExpression}\n     */\n    public static updateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {VariableDeclarator[]} declarations\n     * @param {string} kind\n     * @returns {VariableDeclaration}\n     */\n    public static variableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} id\n     * @param {Expression | null} init\n     * @returns {VariableDeclarator}\n     */\n    public static variableDeclaratorNode (id: ESTree.Identifier, init: ESTree.Expression | null): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement} body\n     * @returns {WhileStatement}\n     */\n    public static whileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { GlobalVariableTemplate1 } from '../templates/GlobalVariableTemplate1';\nimport { GlobalVariableTemplate2 } from '../templates/GlobalVariableTemplate2';\n\n@injectable()\nexport abstract class AbstractCustomNode implements ICustomNode {\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalVariableTemplateFunctions: string[] = [\n        GlobalVariableTemplate1(),\n        GlobalVariableTemplate2()\n    ];\n\n    /**\n     * @type {TStatement[] | null}\n     */\n    protected cachedNode: TStatement[] | null = null;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {unknown[]} args\n     */\n    public abstract initialize (...args: unknown[]): void;\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            this.cachedNode = this.getNodeStructure();\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getGlobalVariableTemplate (): string {\n        return this.randomGenerator\n            .getRandomGenerator()\n            .pickone(AbstractCustomNode.globalVariableTemplateFunctions);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (): TStatement[];\n}\n","module.exports = require(\"estraverse\");","import * as ESTree from 'estree';\n\nexport class NodeMetadata {\n    /**\n     * @param {T} node\n     * @param {Partial<T[\"metadata\"]>} metadata\n     */\n    public static set <T extends ESTree.Node = ESTree.Node> (node: T, metadata: Partial<T['metadata']>): void {\n        node.metadata = Object.assign(node.metadata || {}, metadata);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {keyof T} metadataKey\n     * @returns {T[keyof T] | undefined}\n     */\n    public static get <T extends ESTree.BaseNodeMetadata> (node: ESTree.Node, metadataKey: keyof T): T[keyof T] | undefined {\n        return node.metadata !== undefined\n            ? (<T>node.metadata)[metadataKey]\n            : undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIgnoredNode (node: ESTree.Node): boolean {\n        return NodeMetadata.get(node, 'ignoredNode') === true;\n    }\n\n    /**\n     * @param {Node} identifierNode\n     * @returns {boolean}\n     */\n    public static isRenamedIdentifier (identifierNode: ESTree.Identifier): boolean {\n        return NodeMetadata.get<ESTree.IdentifierNodeMetadata>(identifierNode, 'renamedIdentifier') === true;\n    }\n\n    /**\n     * @param {Node} literalNode\n     * @returns {boolean}\n     */\n    public static isReplacedLiteral (literalNode: ESTree.Literal): boolean {\n        return NodeMetadata.get<ESTree.LiteralNodeMetadata>(literalNode, 'replacedLiteral') === true;\n    }\n}\n","module.exports = require(\"string-template\");","export enum NodeType {\n    ArrayExpression = 'ArrayExpression',\n    ArrayPattern = 'ArrayPattern',\n    ArrowFunctionExpression = 'ArrowFunctionExpression',\n    AssignmentExpression = 'AssignmentExpression',\n    AssignmentPattern = 'AssignmentPattern',\n    AwaitExpression = 'AwaitExpression',\n    BinaryExpression = 'BinaryExpression',\n    BlockStatement = 'BlockStatement',\n    BreakStatement = 'BreakStatement',\n    CallExpression = 'CallExpression',\n    CatchClause = 'CatchClause',\n    ClassDeclaration = 'ClassDeclaration',\n    ContinueStatement = 'ContinueStatement',\n    ExportNamedDeclaration = 'ExportNamedDeclaration',\n    ExpressionStatement = 'ExpressionStatement',\n    FunctionDeclaration = 'FunctionDeclaration',\n    FunctionExpression = 'FunctionExpression',\n    Identifier = 'Identifier',\n    IfStatement = 'IfStatement',\n    ImportDeclaration = 'ImportDeclaration',\n    ImportDefaultSpecifier = 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier = 'ImportNamespaceSpecifier',\n    ImportSpecifier = 'ImportSpecifier',\n    LabeledStatement = 'LabeledStatement',\n    Literal = 'Literal',\n    LogicalExpression = 'LogicalExpression',\n    MemberExpression = 'MemberExpression',\n    MethodDefinition = 'MethodDefinition',\n    ObjectExpression = 'ObjectExpression',\n    ObjectPattern = 'ObjectPattern',\n    Program = 'Program',\n    Property = 'Property',\n    RestElement = 'RestElement',\n    ReturnStatement = 'ReturnStatement',\n    Super = 'Super',\n    SwitchCase = 'SwitchCase',\n    SwitchStatement = 'SwitchStatement',\n    TaggedTemplateExpression = 'TaggedTemplateExpression',\n    TemplateLiteral = 'TemplateLiteral',\n    TryStatement = 'TryStatement',\n    UnaryExpression = 'UnaryExpression',\n    UpdateExpression = 'UpdateExpression',\n    VariableDeclaration = 'VariableDeclaration',\n    VariableDeclarator = 'VariableDeclarator',\n    WhileStatement = 'WhileStatement'\n}\n","export enum IdentifierObfuscatingReplacer {\n    BaseIdentifierObfuscatingReplacer = 'BaseIdentifierObfuscatingReplacer'\n}\n","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { analyzersModule } from './modules/analyzers/AnalyzersModule';\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { convertingTransformersModule } from './modules/node-transformers/ConvertingTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { finalizingTransformersModule } from './modules/node-transformers/FinalizingTransformersModule';\nimport { generatorsModule } from './modules/generators/GeneratorsModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { optionsModule } from './modules/options/OptionsModule';\nimport { preparingTransformersModule } from './modules/node-transformers/PreparingTransformersModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\nimport { utilsModule } from './modules/utils/UtilsModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\n\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Logger } from '../logger/Logger';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscatedCode } from '../source-code/ObfuscatedCode';\nimport { SourceCode } from '../source-code/SourceCode';\nimport { TransformersRunner } from '../node-transformers/TransformersRunner';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    constructor () {\n        this.container = new Container();\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            return (bindingName: T) => {\n                return context.container.getNamed<U>(serviceIdentifier, bindingName);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getCacheFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map <T, U> = new Map();\n\n            return (bindingName: T) => {\n                if (cache.has(bindingName)) {\n                    return <U>cache.get(bindingName);\n                }\n\n                const object: U = context.container.getNamed<U>(serviceIdentifier, bindingName);\n\n                cache.set(bindingName, object);\n\n                return object;\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<U>>} serviceIdentifier\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]} dependencies\n     * @returns {U}\n     */\n    public static getConstructorFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<interfaces.Newable<U>>,\n        ...dependencies: interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map<T, interfaces.Newable<U>> = new Map();\n            const cachedDependencies: Object[] = [];\n\n            return (bindingName: T) => {\n                dependencies.forEach((\n                    dependency: interfaces.ServiceIdentifier<interfaces.Newable<Object>>,\n                    index: number\n                ) => {\n                    if (!cachedDependencies[index]) {\n                        cachedDependencies[index] = context.container.get(dependency);\n                    }\n                });\n\n                if (cache.has(bindingName)) {\n                    return new (<interfaces.Newable<U>>cache.get(bindingName))(...cachedDependencies);\n                }\n\n                const constructor: interfaces.Newable<U> = context.container\n                    .getNamed<interfaces.Newable<U>>(\n                        serviceIdentifier,\n                        bindingName\n                    );\n\n                cache.set(bindingName, constructor);\n\n                return new constructor(...cachedDependencies);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @param {string | number | symbol} named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     * @param {TInputOptions} options\n     */\n    public load (sourceCode: string, sourceMap: string, options: TInputOptions): void {\n        this.container\n            .bind<ISourceCode>(ServiceIdentifiers.ISourceCode)\n            .toDynamicValue(() => new SourceCode(sourceCode, sourceMap))\n            .inSingletonScope();\n\n        this.container\n            .bind<TInputOptions>(ServiceIdentifiers.TInputOptions)\n            .toDynamicValue(() => options)\n            .inSingletonScope();\n\n        this.container\n            .bind<ILogger>(ServiceIdentifiers.ILogger)\n            .to(Logger)\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<ITransformersRunner>(ServiceIdentifiers.ITransformersRunner)\n            .to(TransformersRunner)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode)\n            .to(ObfuscatedCode);\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.Factory__IObfuscatedCode)\n            .toFactory<IObfuscatedCode>((context: interfaces.Context) => {\n                return (obfuscatedCodeAsString: string, sourceMapAsString: string) => {\n                    const obfuscatedCode: IObfuscatedCode = context.container\n                        .get<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode);\n\n                    obfuscatedCode.initialize(obfuscatedCodeAsString, sourceMapAsString);\n\n                    return obfuscatedCode;\n                };\n            });\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(analyzersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(convertingTransformersModule);\n        this.container.load(customNodesModule);\n        this.container.load(finalizingTransformersModule);\n        this.container.load(generatorsModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n        this.container.load(optionsModule);\n        this.container.load(preparingTransformersModule);\n        this.container.load(storagesModule);\n        this.container.load(utilsModule);\n    }\n\n    public unload (): void {\n        this.container.unbindAll();\n    }\n}\n","export enum ControlFlowCustomNode {\n    BinaryExpressionFunctionNode = 'BinaryExpressionFunctionNode',\n    BlockStatementControlFlowFlatteningNode = 'BlockStatementControlFlowFlatteningNode',\n    CallExpressionControlFlowStorageCallNode = 'CallExpressionControlFlowStorageCallNode',\n    CallExpressionFunctionNode = 'CallExpressionFunctionNode',\n    ControlFlowStorageNode = 'ControlFlowStorageNode',\n    ExpressionWithOperatorControlFlowStorageCallNode = 'ExpressionWithOperatorControlFlowStorageCallNode',\n    LogicalExpressionFunctionNode = 'LogicalExpressionFunctionNode',\n    StringLiteralControlFlowStorageCallNode = 'StringLiteralControlFlowStorageCallNode',\n    StringLiteralNode = 'StringLiteralNode'\n}\n","export enum ObfuscationTarget {\n    Browser = 'browser',\n    BrowserNoEval = 'browser-no-eval',\n    Node = 'node'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeStatementUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getParentNodeWithStatements (node: ESTree.Node): TNodeWithStatements {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements[]}\n     */\n    public static getParentNodesWithStatements (node: ESTree.Node): TNodeWithStatements[] {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getNextSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, 1);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getPreviousSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, -1);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {Statement}\n     */\n    public static getRootStatementOfNode (node: ESTree.Node): ESTree.Statement {\n        if (NodeGuards.isProgramNode(node)) {\n            throw new Error('Unable to find root statement for `Program` node');\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getRootStatementOfNode(parentNode);\n        }\n\n        return <ESTree.Statement>node;\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getScopeOfNode (node: ESTree.Node): TNodeWithStatements {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getScopeOfNode(parentNode);\n        }\n\n        return parentNode;\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithStatements[]} nodesWithStatements\n     * @param {number} depth\n     * @returns {TNodeWithStatements[]}\n     */\n    private static getParentNodesWithStatementsRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithStatements: TNodeWithStatements[] = [],\n        depth: number = 0\n    ): TNodeWithStatements[] {\n        if (nodesWithStatements.length >= maxSize) {\n            return nodesWithStatements;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (\n            /**\n             * we can add program node instantly\n             */\n            NodeGuards.isProgramNode(node) ||\n            (NodeGuards.isNodeWithLexicalScopeStatements(node, parentNode) && depth > 0)\n        ) {\n            nodesWithStatements.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeStatementUtils.getParentNodesWithStatementsRecursive(parentNode, maxSize, nodesWithStatements, ++depth);\n        }\n\n        return nodesWithStatements;\n    }\n\n    /**\n     * @param {Statement} statement\n     * @param {number} offset\n     * @returns {TStatement | null}\n     */\n    private static getSiblingStatementByOffset (statement: ESTree.Statement, offset: number): TStatement | null {\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(statement);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(statement);\n\n        return scopeBody[indexInScope + offset] || null;\n    }\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeAppender {\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static append (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n            ...statements\n        ]);\n    }\n\n    /**\n     * Appends node into a first deepest BlockStatement in order of function calls\n     *\n     * For example:\n     *\n     * function Foo () {\n     *     var baz = function () {\n     *\n     *     }\n     *\n     *     baz();\n     * }\n     *\n     * foo();\n     *\n     * Appends node into block statement of `baz` function expression\n     *\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} bodyStatements\n     * @param {number} index\n     */\n    public static appendToOptimalBlockScope (\n        stackTraceData: IStackTraceData[],\n        nodeWithStatements: TNodeWithStatements,\n        bodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        const targetBlockScope: TNodeWithStatements = stackTraceData.length\n            ? NodeAppender.getOptimalBlockScope(stackTraceData, index)\n            : nodeWithStatements;\n\n        NodeAppender.prepend(targetBlockScope, bodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {number} index\n     * @param {number} deep\n     * @returns {BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        stackTraceData: IStackTraceData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: IStackTraceData = stackTraceData[index];\n\n        if (deep <= 0) {\n            throw new Error('Invalid `deep` argument value. Value should be bigger then 0.');\n        }\n\n        if (deep > 1 && firstCall.stackTrace.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.stackTrace, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {Node} target\n     */\n    public static insertAfter (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        target: ESTree.Statement\n    ): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeStatements(nodeWithStatements)\n            .indexOf(target);\n\n        NodeAppender.insertAtIndex(nodeWithStatements, statements, indexInScopeStatement + 1);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {number} index\n     */\n    public static insertAtIndex (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        index: number\n    ): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(0, index),\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(index)\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static prepend (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @returns {TStatement[]}\n     */\n    private static getScopeStatements (nodeWithStatements: TNodeWithStatements): TStatement[] {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            return nodeWithStatements.consequent;\n        }\n\n        return nodeWithStatements.body;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @returns {TStatement[]}\n     */\n    private static parentizeScopeStatementsBeforeAppend (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[]\n    ): TStatement[] {\n        statements.forEach((statement: TStatement) => {\n            statement.parentNode = nodeWithStatements;\n        });\n\n        return statements;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    private static setScopeStatements (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            nodeWithStatements.consequent = <ESTree.Statement[]>statements;\n\n            return;\n        }\n\n        nodeWithStatements.body = statements;\n    }\n}\n","export enum ObfuscationEvent {\n    AfterObfuscation = 'afterObfuscation',\n    BeforeObfuscation = 'beforeObfuscation'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeLexicalScopeUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope}\n     */\n    public static getLexicalScope (node: ESTree.Node): TNodeWithLexicalScope | undefined {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    public static getLexicalScopes (node: ESTree.Node): TNodeWithLexicalScope[] {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node);\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithLexicalScope[]} nodesWithLexicalScope\n     * @param {number} depth\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    private static getLexicalScopesRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithLexicalScope: TNodeWithLexicalScope[] = [],\n        depth: number = 0\n    ): TNodeWithLexicalScope[] {\n        if (nodesWithLexicalScope.length >= maxSize) {\n            return nodesWithLexicalScope;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (NodeGuards.isNodeWithLexicalScope(node)) {\n            nodesWithLexicalScope.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeLexicalScopeUtils.getLexicalScopesRecursive(parentNode, maxSize, nodesWithLexicalScope, ++depth);\n        }\n\n        return nodesWithLexicalScope;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","export enum NodeTransformer {\n    BlockStatementControlFlowTransformer = 'BlockStatementControlFlowTransformer',\n    ClassDeclarationTransformer = 'ClassDeclarationTransformer',\n    CommentsTransformer = 'CommentsTransformer',\n    CustomNodesTransformer = 'CustomNodesTransformer',\n    DeadCodeInjectionTransformer = 'DeadCodeInjectionTransformer',\n    EvalCallExpressionTransformer = 'EvalCallExpressionTransformer',\n    FunctionControlFlowTransformer = 'FunctionControlFlowTransformer',\n    CatchClauseTransformer = 'CatchClauseTransformer',\n    FunctionDeclarationTransformer = 'FunctionDeclarationTransformer',\n    FunctionTransformer = 'FunctionTransformer',\n    ImportDeclarationTransformer = 'ImportDeclarationTransformer',\n    LabeledStatementTransformer = 'LabeledStatementTransformer',\n    LiteralTransformer = 'LiteralTransformer',\n    MemberExpressionTransformer = 'MemberExpressionTransformer',\n    MetadataTransformer = 'MetadataTransformer',\n    MethodDefinitionTransformer = 'MethodDefinitionTransformer',\n    ObfuscatingGuardsTransformer = 'ObfuscatingGuardsTransformer',\n    ObjectExpressionKeysTransformer = 'ObjectExpressionKeysTransformer',\n    ObjectExpressionTransformer = 'ObjectExpressionTransformer',\n    ParentificationTransformer = 'ParentificationTransformer',\n    TemplateLiteralTransformer = 'TemplateLiteralTransformer',\n    VariableDeclarationTransformer = 'VariableDeclarationTransformer',\n    VariablePreserveTransformer = 'VariablePreserveTransformer',\n}\n","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","export enum CustomNode {\n    ConsoleOutputDisableExpressionNode = 'ConsoleOutputDisableExpressionNode',\n    DebugProtectionFunctionCallNode = 'DebugProtectionFunctionCallNode',\n    DebugProtectionFunctionIntervalNode = 'DebugProtectionFunctionIntervalNode',\n    DebugProtectionFunctionNode = 'DebugProtectionFunctionNode',\n    DomainLockNode = 'DomainLockNode',\n    NodeCallsControllerFunctionNode = 'NodeCallsControllerFunctionNode',\n    SelfDefendingUnicodeNode = 'SelfDefendingUnicodeNode',\n    StringArrayCallsWrapper = 'StringArrayCallsWrapper',\n    StringArrayNode = 'StringArrayNode',\n    StringArrayRotateFunctionNode = 'StringArrayRotateFunctionNode'\n}\n","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\n\nclass JavaScriptObfuscatorFacade {\n    /**\n     * @type {string | undefined}\n     */\n    public static version: string = process.env.VERSION || 'unknown';\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} inputOptions\n     * @returns {IObfuscatedCode}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscatedCode {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade();\n\n        inversifyContainerFacade.load(sourceCode, '', inputOptions);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscatedCode: IObfuscatedCode = javaScriptObfuscator.obfuscate(sourceCode);\n\n        inversifyContainerFacade.unload();\n\n        return obfuscatedCode;\n    }\n}\n\nexport { JavaScriptObfuscatorFacade as JavaScriptObfuscator };\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CustomNode } from '../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../enums/event-emitters/ObfuscationEvent';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: ObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public abstract appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void;\n\n    /**\n     * @returns {ObfuscationEvent}\n     */\n    public getAppendEvent (): ObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNode, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNode, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param {CustomNode} customNodeName\n     * @param {callback} callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNode, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n\n    /**\n     * @param {number} stackTraceLength\n     * @returns {number}\n     */\n    protected getRandomStackTraceIndex (stackTraceLength: number): number {\n        return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(stackTraceLength - 1)));\n    }\n}\n","export class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @param {string} url\n     * @returns {string}\n     */\n    public static extractDomainFrom (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n}\n","export enum IdentifierNamesGenerator {\n    HexadecimalIdentifierNamesGenerator = 'hexadecimal',\n    MangledIdentifierNamesGenerator = 'mangled'\n}\n","export enum SourceMapMode {\n    Inline = 'inline',\n    Separate = 'separate'\n}\n","export enum StringArrayEncoding {\n    Base64 = 'base64',\n    Rc4 = 'rc4'\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const NO_ADDITIONAL_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    reservedStrings: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","module.exports = require(\"@babel/runtime/helpers/get\");","export class NumberUtils {\n    /**\n     * @param {number} dec\n     * @returns {string}\n     */\n    public static toHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param {number} number\n     * @returns {boolean}\n     */\n    public static isCeil (number: number): boolean {\n        return number % 1 === 0;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../../../types/node/TNodeWithLexicalScope';\n\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\n@injectable()\nexport abstract class AbstractObfuscatingReplacer implements IObfuscatingReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {SimpleLiteral[\"value\"]} nodeValue\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Node}\n     */\n    public abstract replace (nodeValue: ESTree.SimpleLiteral['value'], lexicalScopeNode?: TNodeWithLexicalScope): ESTree.Node;\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param {Node[]} blockScopeBody\n     * @param {Node} callee\n     * @returns {ICalleeData}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData | null;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    protected readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Map<string, Map<string, string[]>>} identifierDataByControlFlowStorageId\n     * @param {string} controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]>();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: TControlFlowStorage): ESTree.Node;\n\n    /**\n     * @param {ICustomNode} customNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @param {string} replacerId\n     * @param {number} usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: TControlFlowStorage,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            this.randomGenerator.getMathRandom() < usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const key: string = this.randomGenerator.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(key)) {\n                return generateStorageKey(length);\n            }\n\n            return key;\n        };\n        const storageKey: string = generateStorageKey(5);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n","module.exports = require(\"escodegen-wallaby\");","/**\n * @returns {string}\n */\nexport function GlobalVariableNoEvalTemplate (): string {\n    return `\n        var that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    `;\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    config: '',\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0.4,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    reservedStrings: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.75,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","export enum CalleeDataExtractor {\n    FunctionDeclarationCalleeDataExtractor = 'FunctionDeclarationCalleeDataExtractor',\n    FunctionExpressionCalleeDataExtractor = 'FunctionExpressionCalleeDataExtractor',\n    ObjectExpressionCalleeDataExtractor = 'ObjectExpressionCalleeDataExtractor',\n}\n","export enum ControlFlowReplacer {\n    BinaryExpressionControlFlowReplacer = 'BinaryExpressionControlFlowReplacer',\n    CallExpressionControlFlowReplacer = 'CallExpressionControlFlowReplacer',\n    LogicalExpressionControlFlowReplacer = 'LogicalExpressionControlFlowReplacer',\n    StringLiteralControlFlowReplacer = 'StringLiteralControlFlowReplacer'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/typeof\");","module.exports = require(\"espree\");","export enum DeadCodeInjectionCustomNode {\n    BlockStatementDeadCodeInjectionNode = 'BlockStatementDeadCodeInjectionNode'\n}\n","export enum PropertiesExtractor {\n    AssignmentExpressionPropertiesExtractor = 'AssignmentExpressionPropertiesExtractor',\n    VariableDeclaratorPropertiesExtractor = 'VariableDeclaratorPropertiesExtractor'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport abstract class AbstractPropertiesExtractor implements IPropertiesExtractor {\n    /**\n     * @type {Map<ESTree.ObjectExpression, TNodeWithStatements>}\n     */\n    protected readonly cachedHostNodesWithStatementsMap: Map <ESTree.ObjectExpression, TNodeWithStatements> = new Map();\n\n    /**\n     * @type {Map<ESTree.ObjectExpression, ESTree.Statement>}\n     */\n    protected readonly cachedHostStatementsMap: Map <ESTree.ObjectExpression, ESTree.Statement> = new Map();\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Property} propertyNode\n     * @returns {string | null}\n     */\n    protected static getPropertyNodeKeyName (propertyNode: ESTree.Property): string | null {\n        if (!propertyNode.key) {\n            return null;\n        }\n\n        const propertyKeyNode: ESTree.Expression = propertyNode.key;\n\n        if (NodeGuards.isLiteralNode(propertyKeyNode) && typeof propertyKeyNode.value === 'string') {\n            return propertyKeyNode.value;\n        }\n\n        if (NodeGuards.isIdentifierNode(propertyKeyNode)) {\n            return propertyKeyNode.name;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    protected static isProhibitedHostParent (node: ESTree.Node): node is ESTree.Pattern {\n        return NodeGuards.isMemberExpressionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    protected static isProhibitedPattern (node: ESTree.Node): node is ESTree.Pattern {\n        return !node\n            || NodeGuards.isObjectPatternNode(node)\n            || NodeGuards.isArrayPatternNode(node)\n            || NodeGuards.isAssignmentPatternNode(node)\n            || NodeGuards.isRestElementNode(node);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} hostNode\n     * @returns {Node}\n     */\n    public abstract extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.Node\n    ): ESTree.Node;\n\n    /**\n     * @param {Property[]} properties\n     * @param {Expression} memberExpressionHostNode\n     * @returns {[ExpressionStatement[] , number[]]}\n     */\n    protected extractPropertiesToExpressionStatements (\n        properties: ESTree.Property[],\n        memberExpressionHostNode: ESTree.Expression\n    ): [ESTree.ExpressionStatement[], number[]] {\n        const propertiesLength: number = properties.length;\n        const expressionStatements: ESTree.ExpressionStatement[] = [];\n        const removablePropertyIds: number[] = [];\n\n        for (let i: number = 0; i < propertiesLength; i++) {\n            const property: ESTree.Property = properties[i];\n            const propertyValue: ESTree.Expression | ESTree.Pattern = property.value;\n\n            // invalid property nodes\n            if (AbstractPropertiesExtractor.isProhibitedPattern(propertyValue)) {\n                continue;\n            }\n\n            /**\n             * Stage 1: extract property node key names\n             */\n            const propertyKeyName: string | null = AbstractPropertiesExtractor.getPropertyNodeKeyName(property);\n\n            if (!propertyKeyName) {\n                continue;\n            }\n\n            /**\n             * Stage 2: creating new expression statement node with member expression based on removed property\n             */\n            const shouldCreateLiteralNode: boolean = !property.computed\n                || (property.computed && !!property.key && NodeGuards.isLiteralNode(property.key));\n            const memberExpressionProperty: ESTree.Expression = shouldCreateLiteralNode\n                ? NodeFactory.literalNode(propertyKeyName)\n                : NodeFactory.identifierNode(propertyKeyName);\n            const memberExpressionNode: ESTree.MemberExpression = NodeFactory\n                .memberExpressionNode(memberExpressionHostNode, memberExpressionProperty, true);\n            const expressionStatementNode: ESTree.ExpressionStatement = NodeFactory.expressionStatementNode(\n                NodeFactory.assignmentExpressionNode('=', memberExpressionNode, propertyValue)\n            );\n\n            /**\n             * Stage 3: recursively processing nested object expressions\n             */\n            if (NodeGuards.isObjectExpressionNode(property.value)) {\n                this.transformObjectExpressionNode(property.value, memberExpressionNode);\n            }\n\n            /**\n             * Stage 4: filling arrays\n             */\n            expressionStatements.push(expressionStatementNode);\n            removablePropertyIds.push(i);\n        }\n\n        return [expressionStatements, removablePropertyIds];\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {number[]} removablePropertyIds\n     */\n    protected filterExtractedObjectExpressionProperties (\n        objectExpressionNode: ESTree.ObjectExpression,\n        removablePropertyIds: number[]\n    ): void {\n        objectExpressionNode.properties = objectExpressionNode.properties\n            .filter((property: ESTree.Property, index: number) => !removablePropertyIds.includes(index));\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Expression} memberExpressionHostNode\n     * @returns {Node}\n     */\n    protected transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Expression\n    ): ESTree.Node {\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, memberExpressionHostNode);\n\n        const hostStatement: ESTree.Statement = this.getHostStatement(objectExpressionNode);\n        const hostNodeWithStatements: TNodeWithStatements = this.getHostNodeWithStatements(\n            objectExpressionNode,\n            hostStatement\n        );\n\n        this.filterExtractedObjectExpressionProperties(objectExpressionNode, removablePropertyIds);\n        NodeAppender.insertAfter(hostNodeWithStatements, expressionStatements, hostStatement);\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Statement} hostStatement\n     * @returns {TNodeWithStatements}\n     */\n    protected getHostNodeWithStatements (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostStatement: ESTree.Statement\n    ): TNodeWithStatements {\n        if (this.cachedHostNodesWithStatementsMap.has(objectExpressionNode)) {\n            return <TNodeWithStatements>this.cachedHostNodesWithStatementsMap.get(objectExpressionNode);\n        }\n\n        const nodeWithStatements: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(hostStatement);\n\n        this.cachedHostNodesWithStatementsMap.set(objectExpressionNode, nodeWithStatements);\n\n        return nodeWithStatements;\n    }\n\n    /**\n     * Returns host statement of object expression node\n     *\n     * @param {NodeGuards} objectExpressionNode\n     * @returns {Node}\n     */\n    protected getHostStatement (objectExpressionNode: ESTree.ObjectExpression): ESTree.Statement {\n        if (this.cachedHostStatementsMap.has(objectExpressionNode)) {\n            return <ESTree.Statement>this.cachedHostStatementsMap.get(objectExpressionNode);\n        }\n\n        const hostStatement: ESTree.Statement = NodeStatementUtils.getRootStatementOfNode(objectExpressionNode);\n\n        this.cachedHostStatementsMap.set(objectExpressionNode, hostStatement);\n\n        return hostStatement;\n    }\n}\n","export enum CustomNodeGroup {\n    ConsoleOutputCustomNodeGroup = 'ConsoleOutputCustomNodeGroup',\n    DebugProtectionCustomNodeGroup = 'DebugProtectionCustomNodeGroup',\n    DomainLockCustomNodeGroup = 'DomainLockCustomNodeGroup',\n    SelfDefendingCustomNodeGroup = 'SelfDefendingCustomNodeGroup',\n    StringArrayCustomNodeGroup = 'StringArrayCustomNodeGroup'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractIdentifierNamesGenerator implements IIdentifierNamesGenerator {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Array}\n     */\n    protected readonly preservedNames: string[] = [];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public abstract generate (nameLength?: number): string;\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public abstract generateWithPrefix (nameLength?: number): string;\n\n    /**\n     * @param {string} name\n     * @returns {void}\n     */\n    public preserveName (name: string): void {\n        this.preservedNames.push(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (name: string): boolean {\n        return this.notReservedName(name) && !this.preservedNames.includes(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private notReservedName (name: string): boolean {\n        return this.options.reservedNames.length\n            ? !this.options.reservedNames.some((reservedName: string) =>\n                new RegExp(reservedName, 'g').exec(name) !== null\n            )\n            : true;\n\n    }\n}\n","export enum LiteralObfuscatingReplacer {\n    BooleanLiteralObfuscatingReplacer = 'BooleanLiteralObfuscatingReplacer',\n    NumberLiteralObfuscatingReplacer = 'NumberLiteralObfuscatingReplacer',\n    StringLiteralObfuscatingReplacer = 'StringLiteralObfuscatingReplacer'\n}\n","export enum ObfuscatingGuard {\n    BlackListNodeGuard = 'BlackListNodeGuard',\n    ConditionalCommentNodeGuard = 'ConditionalCommentNodeGuard'\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ConditionalCommentObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationEnableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *enable');\n\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationDisableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *disable');\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForCurrentNode: boolean = true;\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForNextNode: boolean | null = null;\n\n    /**\n     * @param {Comment} comment\n     * @returns {boolean}\n     */\n    public static isConditionalComment (comment: ESTree.Comment): boolean {\n        return ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value) ||\n            ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value);\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (this.obfuscationAllowedForNextNode) {\n            this.obfuscationAllowedForCurrentNode = this.obfuscationAllowedForNextNode;\n            this.obfuscationAllowedForNextNode = null;\n        }\n\n        if (!NodeGuards.isNodeWithComments(node)) {\n            return this.obfuscationAllowedForCurrentNode;\n        }\n\n        const leadingComments: ESTree.Comment[] | undefined = node.leadingComments;\n        const trailingComments: ESTree.Comment[] | undefined = node.trailingComments;\n\n        if (leadingComments) {\n            this.obfuscationAllowedForCurrentNode = this.checkComments(leadingComments);\n        }\n\n        if (trailingComments) {\n            this.obfuscationAllowedForNextNode = this.checkComments(trailingComments);\n        }\n\n        return this.obfuscationAllowedForCurrentNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {boolean}\n     */\n    private checkComments (comments: ESTree.Comment[]): boolean {\n        const commentsLength: number = comments.length;\n\n        let obfuscationAllowed: boolean = this.obfuscationAllowedForCurrentNode;\n\n        for (let i: number = 0; i < commentsLength; i++) {\n            const comment: ESTree.Comment = comments[i];\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = true;\n\n                continue;\n            }\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = false;\n            }\n        }\n\n        return obfuscationAllowed;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IMapStorage } from '../interfaces/storages/IMapStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class MapStorage <K, V> implements IMapStorage <K, V> {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {Map <K, V>}\n     */\n    @initializable()\n    protected storage!: Map <K, V>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = new Map <K, V>();\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {K} key\n     * @returns {V}\n     */\n    public get (key: K): V {\n        const value: V | undefined = this.storage.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {K | null}\n     */\n    public getKeyOf (value: V): K | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map<K, V>}\n     */\n    public getStorage (): Map <K, V> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {K} key\n     * @returns {boolean}\n     */\n    public has (key: K): boolean {\n        return this.storage.has(key);\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <K, V>([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {K} key\n     * @param {V} value\n     */\n    public set (key: K, value: V): void {\n        this.storage.set(key, value);\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport md5 from 'md5';\nimport { Chance } from 'chance';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class RandomGenerator implements IRandomGenerator, IInitializable {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {Chance.Chance}\n     */\n    @initializable()\n    private randomGenerator!: Chance.Chance;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private seed!: number;\n\n    /**\n     * @type {ISourceCode}\n     */\n    private readonly sourceCode: ISourceCode;\n\n    /**\n     * @param {ISourceCode} sourceCode\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ISourceCode) sourceCode: ISourceCode,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.sourceCode = sourceCode;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        const getRandomInteger: (min: number, max: number) => number = (min: number, max: number) => {\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        };\n\n        /**\n         * We need to add numbers from md5 hash of source code to input seed to prevent same String Array name\n         * for different bundles with same seed\n         *\n         * @returns {number}\n         */\n        const getSeed: () => number = (): number => {\n            const md5Hash: string = md5(this.sourceCode.getSourceCode());\n\n            return this.seed + Number(md5Hash.replace(/\\D/g, ''));\n        };\n\n        this.seed = this.options.seed !== 0 ? this.options.seed : getRandomInteger(0, 999_999_999);\n        this.randomGenerator = new Chance(getSeed());\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getMathRandom (): number {\n        return this.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public getRandomGenerator (): Chance.Chance {\n        return this.randomGenerator;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomInteger (min: number, max: number): number {\n        return this.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param {number} length\n     * @param {string} pool\n     * @returns {string}\n     */\n    public getRandomString (length: number, pool: string = RandomGenerator.randomGeneratorPool): string {\n        return this.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getSeed (): number {\n        return this.seed;\n    }\n}\n","module.exports = require(\"chalk\");","module.exports = require(\"reflect-metadata\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport chalk, { Chalk } from 'chalk';\n\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { LoggingMessage } from '../enums/logger/LoggingMessage';\nimport { LoggingPrefix } from '../enums/logger/LoggingPrefix';\n\n@injectable()\nexport class Logger implements ILogger {\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorInfo: Chalk = chalk.cyan;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorSuccess: Chalk = chalk.green;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorWarn: Chalk = chalk.yellow;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {Chalk} loggingLevelColor\n     * @param {LoggingPrefix} loggingPrefix\n     * @param {string} loggingMessage\n     * @param {string | number} value\n     */\n    public static log (\n        loggingLevelColor: Chalk,\n        loggingPrefix: LoggingPrefix,\n        loggingMessage: string,\n        value?: string | number,\n    ): void {\n        const processedMessage: string = loggingLevelColor(`\\n${loggingPrefix} ${loggingMessage}`);\n\n        console.log(processedMessage, value || '');\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public info (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorInfo, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public success (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorSuccess, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public warn (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorWarn, LoggingPrefix.Base, loggingMessage, value);\n    }\n}\n","export enum LoggingPrefix {\n    Base = '[javascript-obfuscator]',\n    CLI = '[javascript-obfuscator-cli]'\n}\n","module.exports = require(\"@babel/runtime/helpers/construct\");","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\nimport { IStackTraceAnalyzer } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\n\nimport { CalleeDataExtractor } from '../../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { StackTraceAnalyzer } from '../../../analyzers/stack-trace-analyzer/StackTraceAnalyzer';\n\nexport const analyzersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // stack trace analyzer\n    bind<IStackTraceAnalyzer>(ServiceIdentifiers.IStackTraceAnalyzer)\n        .to(StackTraceAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.ObjectExpressionCalleeDataExtractor);\n\n    // callee data extractor factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>(InversifyContainerFacade\n            .getCacheFactory<CalleeDataExtractor, ICalleeDataExtractor>(\n                ServiceIdentifiers.ICalleeDataExtractor\n            ));\n});\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return null;\n        }\n\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            callee.name\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        if (NodeGuards.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n                callee.name\n            );\n        }\n\n        if (NodeGuards.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isFunctionExpressionNode(node) &&\n                    parentNode &&\n                    NodeGuards.isVariableDeclaratorNode(parentNode) &&\n                    NodeGuards.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../../types/analyzers/stack-trace-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {Property} propertyNode\n     * @param {string | number} nextItemInCallsChain\n     * @returns {boolean}\n     */\n    private static isValidTargetPropertyNode (propertyNode: ESTree.Property, nextItemInCallsChain: string | number): boolean {\n        if (!propertyNode.key) {\n            return false;\n        }\n\n        const isTargetPropertyNodeWithIdentifierKey: boolean =\n            NodeGuards.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n        const isTargetPropertyNodeWithLiteralKey: boolean =\n            NodeGuards.isLiteralNode(propertyNode.key) &&\n            Boolean(propertyNode.key.value) &&\n            propertyNode.key.value === nextItemInCallsChain;\n\n        return isTargetPropertyNodeWithIdentifierKey || isTargetPropertyNodeWithLiteralKey;\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {MemberExpression} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData | null {\n        if (!NodeGuards.isMemberExpressionNode(callee)) {\n            return null;\n        }\n\n        const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n        if (!objectMembersCallsChain.length) {\n            return null;\n        }\n\n        const functionExpressionName: string | number | null = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            objectMembersCallsChain\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param {TObjectMembersCallsChain} currentChain\n     * @param {MemberExpression} memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (NodeGuards.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            NodeGuards.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (NodeGuards.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (NodeGuards.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const objectName: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isVariableDeclaratorNode(node) &&\n                    NodeGuards.isIdentifierNode(node.id) &&\n                    node.init &&\n                    NodeGuards.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param {Property[]} objectExpressionProperties\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const nextItemInCallsChain: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            if (!ObjectExpressionCalleeDataExtractor.isValidTargetPropertyNode(propertyNode, nextItemInCallsChain)) {\n                continue;\n            }\n\n            if (NodeGuards.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (NodeGuards.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../../types/container/stack-trace-analyzer/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CalleeDataExtractor } from '../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\n\n/**\n * This class generates a data with a stack trace of functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class StackTraceAnalyzer implements IStackTraceAnalyzer {\n    /**\n     * @type {CalleeDataExtractor[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractor[] = [\n        CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractor.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractor.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {TCalleeDataExtractorFactory}\n     */\n    private readonly calleeDataExtractorFactory: TCalleeDataExtractorFactory;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param {number} blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = StackTraceAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * StackTraceAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {IStackTraceData[]}\n     */\n    public analyze (astTree: ESTree.Program): IStackTraceData[] {\n        return this.analyzeRecursive(astTree.body);\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        const limitIndex: number = StackTraceAnalyzer.getLimitIndex(blockScopeBody.length);\n        const stackTraceData: IStackTraceData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                    if (!NodeGuards.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeStatementUtils.getParentNodeWithStatements(node)) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(stackTraceData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return stackTraceData;\n    }\n\n    /**\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {CallExpression} callExpressionNode\n     */\n    private analyzeCallExpressionNode (\n        stackTraceData: IStackTraceData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        StackTraceAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractor) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            stackTraceData.push({\n                ...calleeData,\n                stackTrace: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { ControlFlowReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { DeadCodeInjectionTransformer } from '../../../node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer';\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\nimport { StringLiteralControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(DeadCodeInjectionTransformer)\n        .whenTargetNamed(NodeTransformer.DeadCodeInjectionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionControlFlowTransformer);\n\n    // control flow replacers\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(StringLiteralControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.StringLiteralControlFlowReplacer);\n\n    // control flow replacer factory\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>(InversifyContainerFacade\n            .getCacheFactory<ControlFlowReplacer, IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryExpression} binaryExpressionNode\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const replacerId: string = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BinaryExpressionFunctionNode\n        );\n\n        binaryExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedStatementNode (node: ESTree.Node): boolean {\n        const isBreakOrContinueStatement: boolean = NodeGuards.isBreakStatementNode(node)\n            || NodeGuards.isContinueStatementNode(node);\n        const isVariableDeclarationWithLetOrConstKind: boolean = NodeGuards.isVariableDeclarationNode(node)\n            && (node.kind === 'const' || node.kind === 'let');\n        const isClassDeclaration: boolean = NodeGuards.isClassDeclarationNode(node);\n\n        return NodeGuards.isFunctionDeclarationNode(node)\n            || isBreakOrContinueStatement\n            || isVariableDeclarationWithLetOrConstKind\n            || isClassDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static canTransformBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        let canTransform: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isWhileStatementNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (BlockStatementControlFlowTransformer.isProhibitedStatementNode(node)) {\n                    canTransform = false;\n                }\n            }\n        });\n\n        if (blockStatementNode.body.length <= 4) {\n            canTransform = false;\n        }\n\n        return canTransform;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            !BlockStatementControlFlowTransformer.canTransformBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n        const originalKeys: number[] = this.arrayUtils.createWithRange(blockStatementBody.length);\n        const shuffledKeys: number[] = this.arrayUtils.shuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode\n        );\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        const newBlockStatementNode: TStatement = blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionFunctionNode\n        );\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TDeadNodeInjectionCustomNodeFactory } from '../../types/container/custom-nodes/TDeadNodeInjectionCustomNodeFactory';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from '../../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { DeadCodeInjectionCustomNode } from '../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DeadCodeInjectionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly deadCodeInjectionRootAstHostNodeName: string = 'deadCodeInjectionRootAstHostNode';\n\n    /**\n     * @type {number}\n     */\n    private static readonly maxNestedBlockStatementsCount: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly minCollectedBlockStatementsCount: number = 5;\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersToRenameBlockScopeIdentifiers: NodeTransformer[] = [\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {Set <BlockStatement>}\n     */\n    private readonly deadCodeInjectionRootAstHostNodeSet: Set <ESTree.BlockStatement> = new Set();\n\n    /**\n     * @type {ESTree.BlockStatement[]}\n     */\n    private readonly collectedBlockStatements: ESTree.BlockStatement[] = [];\n\n    /**\n     * @type {number}\n     */\n    private collectedBlockStatementsTotalLength: number = 0;\n\n    /**\n     * @type {TDeadNodeInjectionCustomNodeFactory}\n     */\n    private readonly deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {TDeadNodeInjectionCustomNodeFactory} deadCodeInjectionCustomNodeFactory\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n            deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory,\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.deadCodeInjectionCustomNodeFactory = deadCodeInjectionCustomNodeFactory;\n        this.transformersRunner = transformersRunner;\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isProhibitedNodeInsideCollectedBlockStatement (targetNode: ESTree.Node): boolean {\n        return NodeGuards.isBreakStatementNode(targetNode)\n            || NodeGuards.isContinueStatementNode(targetNode)\n            || NodeGuards.isAwaitExpressionNode(targetNode)\n            || NodeGuards.isSuperNode(targetNode);\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isScopeHoistingFunctionDeclaration (targetNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(targetNode)) {\n            return false;\n        }\n\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(targetNode);\n        const scopeBody: ESTree.Statement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? <ESTree.Statement[]>scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(targetNode);\n\n        if (indexInScope === 0) {\n            return false;\n        }\n\n        const slicedBody: ESTree.Statement[] = scopeBody.slice(0, indexInScope);\n        const hostBlockStatementNode: ESTree.BlockStatement = NodeFactory.blockStatementNode(slicedBody);\n        const functionDeclarationName: string = targetNode.id.name;\n\n        let isScopeHoistedFunctionDeclaration: boolean = false;\n\n        estraverse.traverse(hostBlockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isIdentifierNode(node) && node.name === functionDeclarationName) {\n                    isScopeHoistedFunctionDeclaration = true;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isScopeHoistedFunctionDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidCollectedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let nestedBlockStatementsCount: number = 0;\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isBlockStatementNode(node)) {\n                    nestedBlockStatementsCount++;\n                }\n\n                if (\n                    nestedBlockStatementsCount > DeadCodeInjectionTransformer.maxNestedBlockStatementsCount\n                    || DeadCodeInjectionTransformer.isProhibitedNodeInsideCollectedBlockStatement(node)\n                    || DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)\n                ) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isValidBlockStatementNode;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidWrappedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        if (!isValidBlockStatementNode) {\n            return false;\n        }\n\n        const parentNodeWithStatements: TNodeWithStatements = NodeStatementUtils\n            .getParentNodeWithStatements(blockStatementNode);\n\n        return parentNodeWithStatements.type !== NodeType.Program;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.DeadCodeInjection:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return node;\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.deadCodeInjectionRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isDeadCodeInjectionRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {NodeGuards} programNode\n     * @param {NodeGuards} parentNode\n     */\n    public analyzeNode (programNode: ESTree.Node, parentNode: ESTree.Node): void {\n        estraverse.traverse(programNode, {\n            enter: (node: ESTree.Node): void => {\n                if (!NodeGuards.isBlockStatementNode(node)) {\n                    return;\n                }\n\n                const clonedBlockStatementNode: ESTree.BlockStatement = NodeUtils.clone(node);\n\n                if (!DeadCodeInjectionTransformer.isValidCollectedBlockStatementNode(clonedBlockStatementNode)) {\n                    return;\n                }\n\n                /**\n                 * We should transform identifiers in the dead code block statement to avoid conflicts with original code\n                 */\n                const transformedBlockStatementNode: ESTree.BlockStatement =\n                    this.makeClonedBlockStatementNodeUnique(clonedBlockStatementNode);\n\n                this.collectedBlockStatements.push(transformedBlockStatementNode);\n            }\n        });\n\n        this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards | VisitorOption}\n     */\n    public transformNode (\n        blockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.Node | estraverse.VisitorOption {\n        const canBreakTraverse: boolean = !this.collectedBlockStatements.length\n            || this.collectedBlockStatementsTotalLength < DeadCodeInjectionTransformer.minCollectedBlockStatementsCount;\n\n        if (canBreakTraverse) {\n            return estraverse.VisitorOption.Break;\n        }\n\n        if (\n            this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold\n            || !DeadCodeInjectionTransformer.isValidWrappedBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const minInteger: number = 0;\n        const maxInteger: number = this.collectedBlockStatements.length - 1;\n        const randomIndex: number = this.randomGenerator.getRandomInteger(minInteger, maxInteger);\n        const randomBlockStatementNode: ESTree.BlockStatement = this.collectedBlockStatements.splice(randomIndex, 1)[0];\n        const isDuplicateBlockStatementNodes: boolean = randomBlockStatementNode === blockStatementNode;\n\n        if (isDuplicateBlockStatementNodes) {\n            return blockStatementNode;\n        }\n\n        return this.replaceBlockStatementNode(blockStatementNode, randomBlockStatementNode, parentNode);\n    }\n\n    /**\n     * @param {FunctionExpression} deadCodeInjectionRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (deadCodeInjectionRootAstHostNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        const hostNodeFirstStatement: ESTree.Statement = deadCodeInjectionRootAstHostNode.body[0];\n\n        if (!NodeGuards.isFunctionDeclarationNode(hostNodeFirstStatement)) {\n            throw new Error('Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node');\n        }\n\n        return hostNodeFirstStatement.body;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isDeadCodeInjectionRootAstHostNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return NodeGuards.isBlockStatementNode(node) && this.deadCodeInjectionRootAstHostNodeSet.has(node);\n    }\n\n    /**\n     * Make all identifiers in cloned block statement unique\n     *\n     * @param {BlockStatement} clonedBlockStatementNode\n     * @returns {BlockStatement}\n     */\n    private makeClonedBlockStatementNodeUnique (clonedBlockStatementNode: ESTree.BlockStatement): ESTree.BlockStatement {\n        // should wrap cloned block statement node into function node for correct scope encapsulation\n        const hostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], clonedBlockStatementNode);\n\n        NodeUtils.parentizeNode(hostNode, hostNode);\n        NodeUtils.parentizeNode(clonedBlockStatementNode, hostNode);\n\n        return this.transformersRunner.transform(\n            hostNode,\n            DeadCodeInjectionTransformer.transformersToRenameBlockScopeIdentifiers,\n            TransformationStage.Obfuscating\n        ).body;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} randomBlockStatementNode\n     * @param {Node} parentNode\n     * @returns {BlockStatement}\n     */\n    private replaceBlockStatementNode (\n        blockStatementNode: ESTree.BlockStatement,\n        randomBlockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.BlockStatement {\n        /**\n         * Should wrap original random block statement node into the parent block statement node (ast root host node)\n         * with function declaration node. This function declaration node will create block scope for all identifiers\n         * inside random block statement node and this identifiers won't affect identifiers of the rest AST tree.\n         */\n        const deadCodeInjectionRootAstHostNode: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.functionDeclarationNode(\n                DeadCodeInjectionTransformer.deadCodeInjectionRootAstHostNodeName,\n                [],\n                randomBlockStatementNode\n            )\n        ]);\n\n        /**\n         * Should store that host node and then extract random block statement node on the `finalizing` stage\n         */\n        this.deadCodeInjectionRootAstHostNodeSet.add(deadCodeInjectionRootAstHostNode);\n\n        const blockStatementDeadCodeInjectionCustomNode: ICustomNode = this.deadCodeInjectionCustomNodeFactory(\n            DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode\n        );\n\n        blockStatementDeadCodeInjectionCustomNode.initialize(blockStatementNode, deadCodeInjectionRootAstHostNode);\n\n        const newBlockStatementNode: ESTree.BlockStatement = <ESTree.BlockStatement>blockStatementDeadCodeInjectionCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowReplacerFactory } from '../../types/container/node-transformers/TControlFlowReplacerFactory';\nimport { TControlFlowStorage } from '../../types/storages/TControlFlowStorage';\nimport { TControlFlowStorageFactory } from '../../types/container/node-transformers/TControlFlowStorageFactory';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { ControlFlowReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacer>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacer> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacer.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacer.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacer.LogicalExpressionControlFlowReplacer],\n        [NodeType.Literal, ControlFlowReplacer.StringLiteralControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, TControlFlowStorage>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, TControlFlowStorage> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithStatements>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithStatements> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowStorageFactory} controlFlowStorageFactory\n     * @param {TControlFlowReplacerFactory} controlFlowReplacerFactory\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage)\n            controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer)\n            controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!NodeGuards.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithStatements = this.getHostNode(functionNode.body);\n        const controlFlowStorage: TControlFlowStorage = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ControlFlowStorageNode\n        );\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prepend(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {TNodeWithStatements} hostNode\n     * @returns {TControlFlowStorage}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithStatements): TControlFlowStorage {\n        const controlFlowStorage: TControlFlowStorage = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                if (NodeGuards.isSwitchCaseNode(hostNode)) {\n                    hostNode.consequent.shift();\n                } else {\n                    hostNode.body.shift();\n                }\n            }\n\n            const hostControlFlowStorage: TControlFlowStorage = <TControlFlowStorage>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @returns {TNodeWithStatements}\n     */\n    private getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithStatements {\n        const blockScopesOfNode: TNodeWithStatements[] = NodeStatementUtils.getParentNodesWithStatements(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return this.randomGenerator.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: TControlFlowStorage): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | ESTree.Node => {\n                if (NodeMetadata.isIgnoredNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (this.isVisitedFunctionNode(node) || !parentNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacer = <ControlFlowReplacer>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                if (controlFlowReplacerName === undefined) {\n                    return node;\n                }\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalExpression} logicalExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const replacerId: string = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.LogicalExpressionFunctionNode\n        );\n\n        logicalExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!NodeGuards.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !NodeGuards.isLiteralNode(nodeForCheck) &&\n                !NodeGuards.isIdentifierNode(nodeForCheck) &&\n                !NodeGuards.isObjectExpressionNode(nodeForCheck) &&\n                !NodeGuards.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class StringLiteralControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 1;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        literalNode: ESTree.Literal,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (typeof literalNode.value !== 'string' || literalNode.value.length < 3) {\n            return literalNode;\n        }\n\n        const replacerId: string = String(literalNode.value);\n        const literalFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralNode\n        );\n\n        literalFunctionCustomNode.initialize(literalNode.value);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            literalFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            StringLiteralControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { PropertiesExtractor } from '../../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\n\nimport { AssignmentExpressionPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor';\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionKeysTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionKeysTransformer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\nimport { VariableDeclaratorPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor';\n\nexport const convertingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformer.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionKeysTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionKeysTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformer.TemplateLiteralTransformer);\n\n    // properties extractors\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(AssignmentExpressionPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.AssignmentExpressionPropertiesExtractor);\n\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(VariableDeclaratorPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.VariableDeclaratorPropertiesExtractor);\n\n    // properties extractor factory\n    bind<IPropertiesExtractor>(ServiceIdentifiers.Factory__IPropertiesExtractor)\n        .toFactory<IPropertiesExtractor>(InversifyContainerFacade\n            .getCacheFactory<PropertiesExtractor, IPropertiesExtractor>(\n                ServiceIdentifiers.IPropertiesExtractor\n            ));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\n\n@injectable()\nexport class AssignmentExpressionPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {AssignmentExpression} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.AssignmentExpression\n    ): ESTree.Node {\n        const hostParentNode: ESTree.Node | undefined = hostNode.parentNode;\n        const leftNode: ESTree.MemberExpression | ESTree.Pattern = hostNode.left;\n\n        // left node shouldn't be as Pattern node\n        if (AbstractPropertiesExtractor.isProhibitedPattern(leftNode)) {\n            return objectExpressionNode;\n        }\n\n        // left node shouldn't be as Pattern node\n        if (hostParentNode && AbstractPropertiesExtractor.isProhibitedHostParent(hostParentNode)) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            leftNode\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMemberExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MemberExpression} memberExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = NodeFactory.literalNode(memberExpressionNode.property.name);\n        }\n\n        return memberExpressionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMethodDefinitionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            NodeGuards.isIdentifierNode(methodDefinitionNode.key) &&\n            !MethodDefinitionTransformer.ignoredNames.includes(methodDefinitionNode.key.name) &&\n            methodDefinitionNode.computed === false\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = NodeFactory.literalNode(methodDefinitionNode.key.name);\n        }\n\n        return methodDefinitionNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TPropertiesExtractorFactory } from '../../types/container/node-transformers/TPropertiesExtractorFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { PropertiesExtractor } from '../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class ObjectExpressionKeysTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map<string, PropertiesExtractor>}\n     */\n    private static readonly propertiesExtractorsMap: Map <string, PropertiesExtractor> = new Map([\n        [NodeType.AssignmentExpression, PropertiesExtractor.AssignmentExpressionPropertiesExtractor],\n        [NodeType.VariableDeclarator, PropertiesExtractor.VariableDeclaratorPropertiesExtractor]\n    ]);\n\n    /**\n     * @type {TPropertiesExtractorFactory}\n     */\n    private readonly propertiesExtractorFactory: TPropertiesExtractorFactory;\n\n    /**\n     * @param {TPropertiesExtractorFactory} propertiesExtractorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IPropertiesExtractor)\n            propertiesExtractorFactory: TPropertiesExtractorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.propertiesExtractorFactory = propertiesExtractorFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        if (transformationStage !== TransformationStage.Converting) {\n            return null;\n        }\n\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                if (\n                    this.options.transformObjectKeys\n                    && parentNode\n                    && NodeGuards.isObjectExpressionNode(node)\n                ) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * replaces:\n     *     var object = {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *\n     * @param {MemberExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (!objectExpressionNode.properties.length) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractorName: PropertiesExtractor | undefined = ObjectExpressionKeysTransformer\n            .propertiesExtractorsMap\n            .get(parentNode.type);\n\n        if (!propertiesExtractorName) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractor: IPropertiesExtractor = this.propertiesExtractorFactory(propertiesExtractorName);\n\n        return propertiesExtractor.extract(objectExpressionNode, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * replaces:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { 'PSEUDO': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isObjectExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (!property.key) {\n                    return;\n                }\n\n                if (property.computed) {\n                    this.transformComputedProperty(property);\n                } else {\n                    this.transformBaseProperty(property);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformComputedProperty (property: ESTree.Property): void {\n        if (!NodeGuards.isLiteralNode(property.key) || !(typeof property.key.value === 'string')) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.value));\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformBaseProperty (property: ESTree.Property): void {\n        if (property.shorthand) {\n            property.shorthand = false;\n        }\n\n        if (!NodeGuards.isIdentifierNode(property.key)) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.name));\n    }\n\n    /**\n     * @param {string} inputValue\n     * @returns {string}\n     */\n    private getPropertyKeyValue (inputValue: string): string {\n        return this.options.unicodeEscapeSequence\n            ? this.escapeSequenceEncoder.encode(inputValue, true)\n            : inputValue;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && NodeGuards.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node | null} parentNode\n     * @returns {boolean}\n     */\n    private static isValidTemplateLiteralNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.TemplateLiteral {\n        return NodeGuards.isTemplateLiteralNode(node) && !NodeGuards.isTaggedTemplateExpressionNode(parentNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && TemplateLiteralTransformer.isValidTemplateLiteralNode(node, parentNode)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {TemplateLiteral} templateLiteralNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: ESTree.Expression[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(NodeFactory.literalNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(NodeGuards.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(NodeFactory.literalNode(''));\n        }\n\n        let transformedNode: ESTree.Node;\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = NodeFactory.binaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = NodeFactory.binaryExpressionNode('+', root, node);\n            });\n\n            transformedNode = root;\n        } else {\n            transformedNode = nodes[0];\n        }\n\n        NodeUtils.parentizeAst(transformedNode);\n\n        return transformedNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class VariableDeclaratorPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {VariableDeclarator} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.VariableDeclarator\n    ): ESTree.Node {\n        if (\n            !NodeGuards.isIdentifierNode(hostNode.id)\n            || this.isProhibitedObjectExpressionNode(objectExpressionNode, hostNode.id)\n        ) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(objectExpressionNode, hostNode.id);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @returns {VariableDeclarator}\n     */\n    private getHostVariableDeclaratorNode (objectExpressionNode: ESTree.ObjectExpression): ESTree.VariableDeclarator | never {\n        const { parentNode } = objectExpressionNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclaratorNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclarator` node for `ObjectExpression` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {VariableDeclarator} variableDeclaratorNode\n     * @returns {VariableDeclaration}\n     */\n    private getHostVariableDeclarationNode (variableDeclaratorNode: ESTree.VariableDeclarator): ESTree.VariableDeclaration | never {\n        const { parentNode } = variableDeclaratorNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclarationNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclaration` node for `VariableDeclarator` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Identifier} memberExpressionHostNode\n     * @returns {boolean}\n     */\n    private isProhibitedObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Identifier\n    ): boolean {\n        const hostVariableDeclarator: ESTree.VariableDeclarator = this.getHostVariableDeclaratorNode(objectExpressionNode);\n        const hostVariableDeclaration: ESTree.VariableDeclaration = this.getHostVariableDeclarationNode(hostVariableDeclarator);\n        const { declarations } = hostVariableDeclaration;\n        const indexOfDeclarator: number = declarations.indexOf(hostVariableDeclarator);\n        const isLastDeclarator: boolean = indexOfDeclarator === (declarations.length - 1);\n\n        // avoid unnecessary checks\n        if (isLastDeclarator) {\n            return false;\n        }\n\n        const declaratorsAfterCurrentDeclarator: ESTree.VariableDeclarator[] = declarations.slice(indexOfDeclarator);\n\n        let isProhibitedObjectExpressionNode: boolean = false;\n\n        // should mark node as prohibited if that node using inside other variable declarators\n        declaratorsAfterCurrentDeclarator.forEach((variableDeclarator: ESTree.VariableDeclarator) => {\n            estraverse.traverse(variableDeclarator, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | ESTree.Node => {\n                    if (\n                        NodeGuards.isMemberExpressionNode(node)\n                        && NodeGuards.isIdentifierNode(node.object)\n                        && node.object.name === memberExpressionHostNode.name\n                    ) {\n                        isProhibitedObjectExpressionNode = true;\n\n                        return estraverse.VisitorOption.Break;\n                    }\n\n                    return node;\n                }\n            });\n        });\n\n        return isProhibitedObjectExpressionNode;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\n\nimport { ControlFlowCustomNode } from \"../../../enums/custom-nodes/ControlFlowCustomNode\";\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { CustomNodeGroup } from '../../../enums/custom-nodes/CustomNodeGroup';\nimport { DeadCodeInjectionCustomNode } from '../../../enums/custom-nodes/DeadCodeInjectionCustomNode';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { BlockStatementDeadCodeInjectionNode } from '../../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNode.ConsoleOutputDisableExpressionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionCallNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionIntervalNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DomainLockNode)\n        .whenTargetNamed(CustomNode.DomainLockNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNode.NodeCallsControllerFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNode.SelfDefendingUnicodeNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNode.StringArrayCallsWrapper);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayNode)\n        .whenTargetNamed(CustomNode.StringArrayNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNode.StringArrayRotateFunctionNode);\n\n    // control flow custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(ControlFlowCustomNode.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n    // dead code injection custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementDeadCodeInjectionNode)\n        .whenTargetNamed(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getFactory<CustomNode, ICustomNode>(ServiceIdentifiers.ICustomNode));\n\n    // control flow customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ControlFlowCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // dead code injection customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<DeadCodeInjectionCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>(InversifyContainerFacade\n            .getFactory<CustomNodeGroup, ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNode.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const consoleOutputDisableExpressionNode: ICustomNode = this.customNodeFactory(CustomNode.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.append(nodeWithStatements, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = NodeGuards.isSwitchCaseNode(nodeWithStatements)\n                ? nodeWithStatements.consequent.length\n                : nodeWithStatements.body.length;\n            const randomIndex: number = this.randomGenerator.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), randomIndex);\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = this.identifierNamesGenerator.generate();\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const debugProtectionFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionIntervalNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName, callsControllerFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNode.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNode.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNode.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const domainLockNode: ICustomNode = this.customNodeFactory(CustomNode.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNode.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const selfDefendingUnicodeNode: ICustomNode = this.customNodeFactory(CustomNode.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prepend(nodeWithStatements, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode = this.customNodeFactory(CustomNode.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayRotateFunctionNode);\n\n        const stringArrayStorageId: string = this.stringArrayStorage.getStorageId();\n\n        const [stringArrayName, stringArrayCallsWrapperName]: string[] = stringArrayStorageId.split('|');\n\n        let stringArrayRotateValue: number;\n\n        if (this.options.rotateStringArray) {\n            stringArrayRotateValue = this.randomGenerator.getRandomInteger(100, 500);\n        } else {\n            stringArrayRotateValue = 0;\n        }\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n        stringArrayCallsWrapper.initialize(stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(stringArrayName, stringArrayRotateValue);\n\n        this.customNodes.set(CustomNode.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNode.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNode.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator!: BinaryOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.binaryExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate1 (): string {\n    return `\n        var that;\n        \n        try {\n            var getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate2 (): string {\n    return `\n        var getGlobal = function () {\n            var globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        var that = getGlobal();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody!: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray!: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys!: number[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Statement[]} blockStatementBody\n     * @param {number[]} shuffledKeys\n     * @param {number[]} originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const controllerIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const indexIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const structure: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.variableDeclarationNode([\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(controllerIdentifierName),\n                    NodeFactory.callExpressionNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.literalNode(\n                                this.originalKeysIndexesInShuffledArray.join('|')\n                            ),\n                            NodeFactory.identifierNode('split')\n                        ),\n                        [\n                            NodeFactory.literalNode('|')\n                        ]\n                    )\n                ),\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(indexIdentifierName),\n                    NodeFactory.literalNode(0)\n                )\n            ]),\n            NodeFactory.whileStatementNode(\n                NodeFactory.literalNode(true),\n                NodeFactory.blockStatementNode([\n                    NodeFactory.switchStatementNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.identifierNode(controllerIdentifierName),\n                            NodeFactory.updateExpressionNode(\n                                '++',\n                                NodeFactory.identifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            const statement: ESTree.Statement = this.blockStatementBody[key];\n                            const consequent: ESTree.Statement[] = [statement];\n\n                            /**\n                             * We shouldn't add continue statement after return statement\n                             * to prevent `unreachable code after return statement` warnings\n                             */\n                            if (!NodeGuards.isReturnStatementNode(statement)) {\n                                consequent.push(NodeFactory.continueStatement());\n                            }\n\n                            return NodeFactory.switchCaseNode(\n                                NodeFactory.literalNode(String(index)),\n                                consequent\n                            );\n                        })\n                    ),\n                    NodeFactory.breakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator, BlockStatement } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementDeadCodeInjectionNode extends AbstractCustomNode {\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private blockStatementNode!: BlockStatement;\n\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private deadCodeInjectionRootAstHostNode!: BlockStatement;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} deadCodeInjectionRootAstHostNode\n     */\n    public initialize (\n        blockStatementNode: BlockStatement,\n        deadCodeInjectionRootAstHostNode: BlockStatement\n    ): void {\n        this.blockStatementNode = blockStatementNode;\n        this.deadCodeInjectionRootAstHostNode = deadCodeInjectionRootAstHostNode;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const random1: boolean = this.randomGenerator.getMathRandom() > 0.5;\n        const random2: boolean = this.randomGenerator.getMathRandom() > 0.5;\n\n        const operator: BinaryOperator = random1 ? '===' : '!==';\n        const leftString: string = this.randomGenerator.getRandomString(5);\n        const rightString: string = random2 ? leftString : this.randomGenerator.getRandomString(5);\n\n        const [consequent, alternate]: [BlockStatement, BlockStatement] = random1 === random2\n            ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode]\n            : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode];\n\n        const structure: BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.ifStatementNode(\n                NodeFactory.binaryExpressionNode(\n                    operator,\n                    NodeFactory.literalNode(leftString),\n                    NodeFactory.literalNode(rightString)\n                ),\n                consequent,\n                alternate\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\n// tslint:disable\nimport { Expression } from 'estree';\n// tslint:enable\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from \"../../../interfaces/utils/IRandomGenerator\";\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee!: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = NodeFactory.identifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(NodeFactory.identifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    calleeIdentifier,\n                    ...params\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.callExpressionNode(\n                            calleeIdentifier,\n                            params\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {TControlFlowStorage}\n     */\n    @initializable()\n    private controlFlowStorage!: TControlFlowStorage;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    public initialize (controlFlowStorage: TControlFlowStorage): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const propertyNodes: ESTree.Property[] = Array\n            .from<[string, ICustomNode]>(this.controlFlowStorage.getStorage())\n            .map(([key, value]: [string, ICustomNode]) => {\n                const node: ESTree.Node = value.getNode()[0];\n\n                if (!NodeGuards.isExpressionStatementNode(node)) {\n                    throw new Error('Function node for control flow storage object should be passed inside the `ExpressionStatement` node!');\n                }\n\n                return NodeFactory.propertyNode(\n                    NodeFactory.identifierNode(key),\n                    node.expression\n                );\n            });\n\n        let structure: ESTree.Node = NodeFactory.variableDeclarationNode([\n            NodeFactory.variableDeclaratorNode(\n                NodeFactory.identifierNode(this.controlFlowStorage.getStorageId()),\n                NodeFactory.objectExpressionNode(propertyNodes)\n            )\n        ]);\n\n        structure = NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: this.identifierNamesGenerator.generate(),\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        var {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func = function () {};\n            \n            {globalVariableTemplate}\n                        \n            if (!that.console) {\n                that.console = (function (func){\n                    var c = {};\n                    \n                    c.log = func;\n                    c.warn = func;\n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.trace = func;\n                    \n                    return c;\n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func;\n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string, callsControllerFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `\n        (function () {\n            {singleNodeCallControllerFunctionName}(this, function () {\n                var regExp1 = new RegExp('function *\\\\\\\\( *\\\\\\\\)');\n                var regExp2 = new RegExp('\\\\\\\\+\\\\\\\\+ *\\\\(?:_0x(?:[a-f0-9]){4,6}|(?:\\\\\\\\b|\\\\\\\\d)[a-z0-9]{1,4}(?:\\\\\\\\b|\\\\\\\\d)\\\\)', 'i');\n       \n                var result = {debugProtectionFunctionName}('init');\n                \n                if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                    result('0');\n                } else {\n                    {debugProtectionFunctionName}();\n                }\n            })();\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebuggerTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate';\nimport { DebuggerTemplateNoEval } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval';\nimport { DebugProtectionFunctionTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const debuggerTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? DebuggerTemplate()\n            : DebuggerTemplateNoEval();\n\n        return format(DebugProtectionFunctionTemplate(), {\n            debuggerTemplate,\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplate (): string {\n    return `\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplateNoEval (): string {\n    return `\n        if (typeof counter === 'string') {\n            var func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n            \n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.cryptUtils = cryptUtils;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = this.cryptUtils.hideString(\n            domainsString,\n            domainsString.length * 3\n        );\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(DomainLockNodeTemplate(), {\n            domainLockFunctionName: this.identifierNamesGenerator.generate(),\n            diff: diff,\n            domains: hiddenDomainsString,\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        var {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            var func = function () {\n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        for (var i = 0; i < 1000; i--) {\n                            var isPositive = i > 0;\n                            \n                            switch (isPositive) {\n                                case true:\n                                    return this.item + '_' + this.value + '_' + i;\n                                default:\n                                    this.item + '_' + this.value;\n                            }\n                        }\n                    }()\n                };\n            };\n                        \n            var regExp = new RegExp(\"[{diff}]\", \"g\");\n            var domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            var document;\n            var domain;\n            var location;\n            var hostname;\n\n            for (var d in that) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (var d1 in that[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n\n            if (!(\"~\" > domain)) {\n                for (var d2 in that[document]) {\n                    if (d2.length == 8 && d2.charCodeAt(7) == 110 && d2.charCodeAt(0) == 108) {\n                        location = d2;\n                        \n                        break;\n                    }\n                }\n\n                for (var d3 in that[document][location]) {\n                    if (d3.length == 8 && d3.charCodeAt(7) == 101 && d3.charCodeAt(0) == 104) {\n                        hostname = d3;\n                        \n                        break;\n                    }\n                }\n            }\n            \n            if (!document || !that[document]) {\n                return;\n            }\n            \n            var documentDomain = that[document][domain];\n            var documentLocationHostName = !!that[document][location] && that[document][location][hostname];\n            var currentDomain = documentDomain || documentLocationHostName;\n          \n            if (!currentDomain) {\n                return;\n            }\n          \n            var ok = false;\n                        \n            for (var i = 0; i < domains.length; i++) {\n                var domain = domains[i];\n                var position = currentDomain.length - domain.length;\n                var lastIndex = currentDomain.indexOf(domain, position);\n                var endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue!: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue!: Expression;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} leftValue\n     * @param {Expression} rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator!: LogicalOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.logicalExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/SingleNodeCallControllerTemplate';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent!: ObfuscationEvent;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {ObfuscationEvent} appendEvent\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (appendEvent: ObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        if (this.appendEvent === ObfuscationEvent.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                format(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    identifierNamesGenerator: this.options.identifierNamesGenerator,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return format(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        var {singleNodeCallControllerFunctionName} = (function(){\n            var firstCall = true;\n            \n            return function (context, fn){\n                var rfn = firstCall ? function(){\n                    if(fn){\n                        var res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                selfDefendingFunctionName: this.identifierNamesGenerator.generate(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed,\n                unicodeEscapeSequence: true\n            }\n        ).getObfuscatedCode();\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `е` character instead latin\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`(\\\\\\\\[x|u](\\\\w){2,4})+`, true)\n                }');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indеxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indеxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/AtobTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\nimport { Rc4Template } from '../../templates/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {string} stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n        const atobPolyfill: string = format(AtobTemplate(), { globalVariableTemplate });\n\n        let decodeStringArrayTemplate: string = '';\n        let selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = format(\n                SelfDefendingTemplate(\n                    this.randomGenerator,\n                    this.escapeSequenceEncoder\n                ),\n                {\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }\n            );\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeStringArrayTemplate = format(\n                    StringArrayRc4DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        rc4Polyfill: Rc4Template(),\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                decodeStringArrayTemplate = format(\n                    StringArrayBase64DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            {globalVariableTemplate}\n            \n            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            that.atob || (\n                that.atob = function(input) {\n                    var str = String(input).replace(/=+$/, '');\n                    for (\n                        var bc = 0, bs, buffer, idx = 0, output = '';\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                return output;\n            });\n        })();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        var rc4 = function (str, key) {\n            var s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (var k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t        \n\t        for (var i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (var y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n * @constructor\n */\nexport function SelfDefendingTemplate (\n    randomGenerator: IRandomGenerator,\n    escapeSequenceEncoder: IEscapeSequenceEncoder\n): string {\n    const identifierLength: number = 6;\n    const rc4BytesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const statesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const newStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const firstStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const secondStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const checkStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const runStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const getStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const stateResultIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    \n    return `\n        var StatesClass = function (${rc4BytesIdentifier}) {\n            this.${rc4BytesIdentifier} = ${rc4BytesIdentifier};\n            this.${statesIdentifier} = [1, 0, 0];\n            this.${newStateIdentifier} = function(){return 'newState';};\n            this.${firstStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`, true)\n            }';\n            this.${secondStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`['|\"].+['|\"];? *}`, true)\n            }';\n        };\n        \n        StatesClass.prototype.${checkStateIdentifier} = function () {\n            var regExp = new RegExp(this.${firstStateIdentifier} + this.${secondStateIdentifier});\n            var expression = regExp.test(this.${newStateIdentifier}.toString())\n                ? --this.${statesIdentifier}[1]\n                : --this.${statesIdentifier}[0];\n            \n            return this.${runStateIdentifier}(expression);\n        };\n        \n        StatesClass.prototype.${runStateIdentifier} = function (${stateResultIdentifier}) {\n            if (!Boolean(~${stateResultIdentifier})) {\n                return ${stateResultIdentifier};\n            }\n            \n            return this.${getStateIdentifier}(this.${rc4BytesIdentifier});\n        };\n\n        StatesClass.prototype.${getStateIdentifier} = function (${rc4BytesIdentifier}) {\n            for (var i = 0, len = this.${statesIdentifier}.length; i < len; i++) {\n                this.${statesIdentifier}.push(Math.round(Math.random()));\n                len = this.${statesIdentifier}.length;\n            }\n            \n            return ${rc4BytesIdentifier}(this.${statesIdentifier}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${checkStateIdentifier}();\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayBase64DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const base64DecodeFunctionIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n\n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier} = function (str) {\n                var string = atob(str);\n                var newStringChars = [];\n                \n                for (var i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n                  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier}(value);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        var {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            var value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayRc4DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const rc4Identifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const onceIdentifier: string = randomGenerator.getRandomString(identifierLength);\n  \n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${rc4Identifier} = rc4;\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.${onceIdentifier} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${onceIdentifier} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${rc4Identifier}(value, key);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\nimport { TStringArrayStorage } from '../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArrayStorage } from '../../storages/string-array/StringArrayStorage';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {TStringArrayStorage}\n     */\n    @initializable()\n    private stringArrayStorage!: TStringArrayStorage;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: TStringArrayStorage,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        (<StringArrayStorage>this.stringArrayStorage).rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        var {stringArrayName} = [{stringArray}];\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { NumberUtils } from '../../utils/NumberUtils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const timesName: string = this.identifierNamesGenerator.generate();\n        const whileFunctionName: string = this.identifierNamesGenerator.generate();\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotateValue: NumberUtils.toHex(this.stringArrayRotateValue),\n                whileFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var selfDefendingFunc = function () {\n            var object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    var updatedCookie = name + \"=\" + value;\n\n                    var i = 0;\n                                                            \n                    for (var i = 0, len = options.length; i < len; i++) {\n                        var propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        var propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {\n                    document = document || function (value) { return value };\n                    var matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    var func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            var cookie = '';\n            var result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');\n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            var {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class StringLiteralControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.memberExpressionNode(\n                NodeFactory.identifierNode(this.controlFlowStorageName),\n                NodeFactory.identifierNode(this.controlFlowStorageKey)\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class StringLiteralNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private literalValue!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} literalValue\n     */\n    public initialize (literalValue: string): void {\n        this.literalValue = literalValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.literalNode(this.literalValue)\n        );\n\n        return [structure];\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\n\nexport const finalizingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // finalizing transformers\n\n});\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { IdentifierNamesGenerator } from '../../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\nimport { HexadecimalIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator';\nimport { MangledIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/MangledIdentifierNamesGenerator';\n\nexport const generatorsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // identifier name generators\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(HexadecimalIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(MangledIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.MangledIdentifierNamesGenerator);\n\n    // identifier name generator factory\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n        .toFactory<IIdentifierNamesGenerator>((context: interfaces.Context): (options: IOptions) => IIdentifierNamesGenerator => {\n            let cachedIdentifierNamesGenerator: IIdentifierNamesGenerator | null = null;\n\n            return (options: IOptions) => {\n                if (cachedIdentifierNamesGenerator) {\n                    return cachedIdentifierNamesGenerator;\n                }\n\n                let identifierNamesGenerator: IIdentifierNamesGenerator;\n\n                switch (options.identifierNamesGenerator) {\n                    case IdentifierNamesGenerator.MangledIdentifierNamesGenerator:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n                        );\n\n                        break;\n\n                    case IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:\n                    default:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator\n                        );\n                }\n\n                cachedIdentifierNamesGenerator = identifierNamesGenerator;\n\n                return identifierNamesGenerator;\n            };\n        });\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\nimport { NumberUtils } from '../../utils/NumberUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class HexadecimalIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {number}\n     */\n    private static readonly baseIdentifierNameLength: number = 6;\n\n    /**\n     * @type {Set<string>}\n     */\n    private readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generate (nameLength?: number): string {\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99_999_999;\n        const randomInteger: number = this.randomGenerator.getRandomInteger(rangeMinInteger, rangeMaxInteger);\n        const hexadecimalNumber: string = NumberUtils.toHex(randomInteger);\n        const prefixLength: number = Utils.hexadecimalPrefix.length + 1;\n        const baseNameLength: number = nameLength\n            ? nameLength - prefixLength\n            : HexadecimalIdentifierNamesGenerator.baseIdentifierNameLength;\n        const baseIdentifierName: string = hexadecimalNumber.substr(0, baseNameLength);\n        const identifierName: string = `_${Utils.hexadecimalPrefix}${baseIdentifierName}`;\n\n        if (this.randomVariableNameSet.has(identifierName)) {\n            return this.generate(nameLength);\n        }\n\n        this.randomVariableNameSet.add(identifierName);\n\n        return identifierName;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generateWithPrefix (nameLength?: number): string {\n        const identifierName: string = this.generate(nameLength);\n\n        return `${this.options.identifiersPrefix}${identifierName}`.replace('__', '_');\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class MangledIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {string}\n     */\n    private static readonly initMangledNameCharacter: string = '9';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly nameSequence: string[] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n    /**\n     * Reserved JS words with length of 2-4 symbols that can be possible generated with this replacer\n     *\n     * @type {string[]}\n     */\n    private static readonly reservedNames: string[] = [\n        'byte', 'case', 'char', 'do', 'else', 'enum', 'eval', 'for', 'goto',\n        'if', 'in', 'int', 'let', 'long', 'new', 'null', 'this', 'true', 'try',\n        'var', 'void', 'with'\n    ];\n\n    /**\n     * @type {string}\n     */\n    private previousMangledName: string = MangledIdentifierNamesGenerator.initMangledNameCharacter;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * We can only ignore limited nameLength, it has no sense here\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generate (nameLength?: number): string {\n        const identifierName: string = this.generateNewMangledName(this.previousMangledName);\n\n        this.previousMangledName = identifierName;\n\n        return identifierName;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generateWithPrefix (nameLength?: number): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate(nameLength);\n\n        return `${prefix}${identifierName}`;\n    }\n\n    /**\n     * @param {string} mangledName\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (mangledName: string): boolean {\n        return super.isValidIdentifierName(mangledName)\n            && !MangledIdentifierNamesGenerator.reservedNames.includes(mangledName);\n    }\n\n    /**\n     * @param {string} previousMangledName\n     * @returns {string}\n     */\n    private generateNewMangledName (previousMangledName: string): string {\n        const generateNewMangledName: (name: string) => string = (name: string): string => {\n            const nameSequence: string[] = MangledIdentifierNamesGenerator.nameSequence;\n            const nameLength: number = name.length;\n\n            const zeroSequence: (num: number) => string = (num: number): string => {\n                return '0'.repeat(num);\n            };\n\n            let index: number = nameLength - 1;\n\n            do {\n                const character: string = name.charAt(index);\n                const indexInSequence: number = nameSequence.indexOf(character);\n                const lastNameSequenceIndex: number = nameSequence.length - 1;\n\n                if (indexInSequence !== lastNameSequenceIndex) {\n                    const previousNamePart: string = name.substring(0, index);\n                    const nextCharacter: string = nameSequence[indexInSequence + 1];\n                    const zeroSequenceLength: number = nameLength - (index + 1);\n                    const zeroSequenceCharacters: string = zeroSequence(zeroSequenceLength);\n\n                    return previousNamePart + nextCharacter + zeroSequenceCharacters;\n                }\n\n                --index;\n            } while (index >= 0);\n\n            return `a${zeroSequence(nameLength)}`;\n        };\n\n        let newMangledName: string = generateNewMangledName(previousMangledName);\n\n        if (!this.isValidIdentifierName(newMangledName)) {\n            newMangledName = this.generateNewMangledName(newMangledName);\n        }\n\n        return newMangledName;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>(InversifyContainerFacade\n            .getCacheFactory<NodeTransformer, INodeTransformer>(ServiceIdentifiers.INodeTransformer));\n});\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\n\nimport { IdentifierObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { LiteralObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BaseIdentifierObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer';\nimport { BooleanLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer';\nimport { CatchClauseTransformer } from '../../../node-transformers/obfuscating-transformers/CatchClauseTransformer';\nimport { ClassDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ClassDeclarationTransformer';\nimport { FunctionDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionDeclarationTransformer';\nimport { FunctionTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionTransformer';\nimport { ImportDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ImportDeclarationTransformer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { NumberLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer';\nimport { StringLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer';\nimport { VariableDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/VariableDeclarationTransformer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // obfuscating transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CatchClauseTransformer)\n        .whenTargetNamed(NodeTransformer.CatchClauseTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ClassDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ClassDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ImportDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ImportDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformer.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformer.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariableDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.VariableDeclarationTransformer);\n\n    // literal obfuscating replacers\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(BooleanLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(NumberLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(StringLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer);\n\n    // identifier obfuscating replacers\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.IIdentifierObfuscatingReplacer)\n        .to(BaseIdentifierObfuscatingReplacer)\n        .whenTargetNamed(IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer);\n\n    // literal obfuscating replacer factory\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n        .toFactory<IObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<LiteralObfuscatingReplacer, IObfuscatingReplacer>(\n                ServiceIdentifiers.IObfuscatingReplacer\n            ));\n\n    // identifier obfuscating replacer factory\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n        .toFactory<IIdentifierObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<IdentifierObfuscatingReplacer, IIdentifierObfuscatingReplacer>(\n                ServiceIdentifiers.IIdentifierObfuscatingReplacer\n            ));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithLexicalScope } from '../../../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierNamesGenerator } from '../../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IIdentifierObfuscatingReplacer } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BaseIdentifierObfuscatingReplacer extends AbstractObfuscatingReplacer implements IIdentifierObfuscatingReplacer {\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {Map<TNodeWithLexicalScope, Map<string, string>>}\n     */\n    private readonly blockScopesMap: Map<TNodeWithLexicalScope, Map<string, string>> = new Map();\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Identifier}\n     */\n    public replace (nodeValue: string, lexicalScopeNode: TNodeWithLexicalScope): ESTree.Identifier {\n        if (this.blockScopesMap.has(lexicalScopeNode)) {\n            const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n            if (namesMap.has(nodeValue)) {\n                nodeValue = <string>namesMap.get(nodeValue);\n            }\n        }\n\n        return NodeFactory.identifierNode(nodeValue);\n    }\n\n    /**\n     * Store `nodeName` of global identifiers as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeGlobalName (nodeName: string, lexicalScopeNode: TNodeWithLexicalScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generateWithPrefix();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * Store `nodeName` of local identifier as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeLocalName (nodeName: string, lexicalScopeNode: TNodeWithLexicalScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generate();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * Preserve `name` to protect it from further using.\n     *\n     * @param {string} name\n     */\n    public preserveName (name: string): void {\n        this.identifierNamesGenerator.preserveName(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        if (!this.options.reservedStrings.length) {\n            return false;\n        }\n\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BooleanLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getTrueUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode()\n        );\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getFalseUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            NodeFactory.arrayExpressionNode()\n        );\n    }\n\n    /**\n     * @param {boolean} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: boolean): ESTree.Node {\n        return nodeValue\n            ? BooleanLiteralObfuscatingReplacer.getTrueUnaryExpressionNode()\n            : BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\n@injectable()\nexport class CatchClauseTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isCatchClauseNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (catchClauseNode: ESTree.CatchClause, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(catchClauseNode);\n\n        if (!lexicalScopeNode) {\n            return catchClauseNode;\n        }\n\n        this.storeCatchClauseParam(catchClauseNode, lexicalScopeNode);\n        this.replaceCatchClauseParam(catchClauseNode, lexicalScopeNode);\n\n        return catchClauseNode;\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        if (NodeGuards.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierObfuscatingReplacer.storeLocalName(catchClauseNode.param.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     class Foo { //... };\n *     new Foo();\n *\n * on:\n *     class _0x12d45f { //... };\n *     new _0x12d45f();\n */\n@injectable()\nexport class ClassDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isClassDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (classDeclarationNode: ESTree.ClassDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(classDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return classDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return classDeclarationNode;\n        }\n\n        this.storeClassName(classDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(classDeclarationNode, lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return classDeclarationNode;\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeClassName (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(classDeclarationNode.id.name, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(classDeclarationNode.id.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(classDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\n@injectable()\nexport class FunctionDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isFunctionDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionDeclarationNode: ESTree.FunctionDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(parentNode);\n\n        if (!lexicalScopeNode) {\n            return functionDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return functionDeclarationNode;\n        }\n\n        this.storeFunctionName(functionDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(functionDeclarationNode, lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return functionDeclarationNode;\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeFunctionName (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(functionDeclarationNode.id.name, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(functionDeclarationNode.id.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(functionDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && (parentNode !== lexicalScopeNode)\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeType } from '../../enums/node/NodeType';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\n@injectable()\nexport class FunctionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private static isProhibitedIdentifierOfPropertyNode (\n        node: ESTree.Node,\n        parentNode: ESTree.Node | null\n    ): node is ESTree.Identifier {\n        return NodeGuards.isIdentifierNode(node)\n            && !!parentNode\n            && NodeGuards.isPropertyNode(parentNode)\n            && parentNode.key === node;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedIdentifierOfShorthandPropertyNode (\n        node: ESTree.Node,\n    ): node is ESTree.Property & {key: ESTree.Identifier} {\n        return NodeGuards.isPropertyNode(node)\n            && node.shorthand\n            && NodeGuards.isIdentifierNode(node.key);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isFunctionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(functionNode);\n\n        if (!lexicalScopeNode) {\n            return functionNode;\n        }\n\n        this.storeFunctionParams(functionNode, lexicalScopeNode);\n        this.replaceFunctionParams(functionNode, lexicalScopeNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {Identifier} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isGlobalFunctionDeclarationIdentifier (node: ESTree.Identifier, parentNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(parentNode) || parentNode.id !== node) {\n            return false;\n        }\n\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScopes(parentNode)[1];\n\n        if (!lexicalScopeNode) {\n            return false;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        return !this.options.renameGlobals && isGlobalDeclaration;\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeFunctionParams (functionNode: ESTree.Function, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const visitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                // should check with identifier as first argument,\n                // because prohibited identifier can be easily ignored\n                if (FunctionTransformer.isProhibitedIdentifierOfPropertyNode(node, parentNode)) {\n                    return;\n                }\n\n                if (NodeGuards.isAssignmentPatternNode(node) && NodeGuards.isIdentifierNode(node.left)) {\n                    this.identifierObfuscatingReplacer.storeLocalName(node.left.name, lexicalScopeNode);\n\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (NodeGuards.isIdentifierNode(node)) {\n                    this.identifierObfuscatingReplacer.storeLocalName(node.name, lexicalScopeNode);\n                }\n            }\n        };\n\n        functionNode.params.forEach((paramsNode: ESTree.Node) => {\n            estraverse.traverse(paramsNode, visitor);\n        });\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Set<string>} ignoredIdentifierNamesSet\n     */\n    private replaceFunctionParams (\n        functionNode: ESTree.Function,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        ignoredIdentifierNamesSet: Set <string> = new Set()\n    ): void {\n        const visitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void | estraverse.VisitorOption => {\n                /**\n                 * should process nested functions in different traverse loop to avoid wrong code generation\n                 */\n                if (NodeGuards.isFunctionNode(node) && node !== functionNode) {\n                    this.replaceFunctionParams(node, lexicalScopeNode, new Set(ignoredIdentifierNamesSet));\n\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                /**\n                 * should ignore all shorthand `key` identifiers of the `PropertyNode`\n                 */\n                if (FunctionTransformer.isProhibitedIdentifierOfShorthandPropertyNode(node)) {\n                    ignoredIdentifierNamesSet.add(node.key.name);\n\n                    return;\n                }\n\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                    && !ignoredIdentifierNamesSet.has(node.name)\n                ) {\n                    // should ignore identifiers of global function declarations\n                    if (this.isGlobalFunctionDeclarationIdentifier(node, parentNode)) {\n                        return;\n                    }\n\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        };\n\n        estraverse.replace(functionNode, visitor);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TImportSpecifier } from '../../types/node/TimportSpecifier';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     import foo from './foo';\n *     import * as bar from './bar';\n *\n * on:\n *     import _0x12d45f from './foo';\n *     import * as _0x12d45f from './bar';\n */\n@injectable()\nexport class ImportDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TImportSpecifier} importSpecifierNode\n     * @returns {boolean}\n     */\n    private static isProhibitedImportSpecifierNode (importSpecifierNode: TImportSpecifier): boolean {\n        return NodeGuards.isImportSpecifierNode(importSpecifierNode)\n            && importSpecifierNode.imported.name === importSpecifierNode.local.name;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isImportDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (importDeclarationNode: ESTree.ImportDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(importDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return importDeclarationNode;\n        }\n\n        this.storeImportSpecifierNames(importDeclarationNode, lexicalScopeNode);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return importDeclarationNode;\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeImportSpecifierNames (\n        importDeclarationNode: ESTree.ImportDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        importDeclarationNode.specifiers.forEach((importSpecifierNode: TImportSpecifier) => {\n            if (ImportDeclarationTransformer.isProhibitedImportSpecifierNode(importSpecifierNode)) {\n                return;\n            }\n\n            this.identifierObfuscatingReplacer.storeGlobalName(importSpecifierNode.local.name, lexicalScopeNode);\n        });\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] =\n            <ESTree.Identifier[]>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        });\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiers);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLabeledStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(labeledStatementNode);\n\n        if (!lexicalScopeNode) {\n            return labeledStatementNode;\n        }\n\n        this.storeLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n        this.replaceLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        this.identifierObfuscatingReplacer.storeLocalName(labeledStatementNode.label.name, lexicalScopeNode);\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isLabelIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n\n                    node.name = newIdentifier.name;\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TLiteralObfuscatingReplacerFactory } from '../../types/container/node-transformers/TLiteralObfuscatingReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { LiteralObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TLiteralObfuscatingReplacerFactory}\n     */\n    private readonly literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory;\n\n    /**\n     * @param {TLiteralObfuscatingReplacerFactory} literalObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n            literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.literalObfuscatingReplacerFactory = literalObfuscatingReplacerFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLiteralNode(node) && !NodeMetadata.isReplacedLiteral(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (this.isProhibitedNode(literalNode, parentNode)) {\n            return literalNode;\n        }\n\n        let newLiteralNode: ESTree.Node;\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer\n                ).replace(literalNode.value);\n\n                break;\n\n            case 'number':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer\n                ).replace(literalNode.value);\n\n                break;\n\n            case 'string':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer\n                ).replace(literalNode.value);\n\n                break;\n\n            default:\n                newLiteralNode = literalNode;\n        }\n\n        NodeUtils.parentizeNode(newLiteralNode, parentNode);\n\n        return newLiteralNode;\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): boolean {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return true;\n        }\n\n        if (NodeGuards.isImportDeclarationNode(parentNode)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param {number} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: number): ESTree.Node {\n        let rawValue: string;\n\n        if (this.numberLiteralCache.has(nodeValue)) {\n            rawValue = <string>this.numberLiteralCache.get(nodeValue);\n        } else {\n            if (!NumberUtils.isCeil(nodeValue)) {\n                rawValue = String(nodeValue);\n            } else {\n                rawValue = `${Utils.hexadecimalPrefix}${NumberUtils.toHex(nodeValue)}`;\n            }\n\n            this.numberLiteralCache.set(nodeValue, rawValue);\n        }\n\n        return NodeFactory.literalNode(nodeValue, rawValue);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStringArrayStorage } from '../../../../types/storages/TStringArrayStorage';\n\nimport { ICryptUtils } from '../../../../interfaces/utils/ICryptUtils';\nimport { IEncodedValue } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IEncodedValue';\nimport { IEscapeSequenceEncoder } from '../../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayIndexData } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IStringArrayIndexData';\n\nimport { StringArrayEncoding } from '../../../../enums/StringArrayEncoding';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeMetadata } from '../../../../node/NodeMetadata';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeyLength: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeysCount: number = 50;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {Map<string, ESTree.Node>}\n     */\n    private readonly nodesCache: Map <string, ESTree.Node> = new Map();\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralHexadecimalIndexCache: Map <string, string> = new Map();\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(\n            options\n        );\n\n        this.stringArrayStorage = stringArrayStorage;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n        this.randomGenerator = randomGenerator;\n        this.cryptUtils = cryptUtils;\n\n        this.rc4Keys = this.randomGenerator.getRandomGenerator()\n            .n(\n                () => this.randomGenerator.getRandomGenerator().string({\n                    length: StringLiteralObfuscatingReplacer.rc4KeyLength\n                }),\n                StringLiteralObfuscatingReplacer.rc4KeysCount\n            );\n    }\n\n    /**\n     * @param {string} hexadecimalIndex\n     * @returns {Literal}\n     */\n    private static getHexadecimalLiteralNode (hexadecimalIndex: string): ESTree.Literal {\n        const hexadecimalLiteralNode: ESTree.Literal = NodeFactory.literalNode(hexadecimalIndex);\n\n        NodeMetadata.set(hexadecimalLiteralNode, { replacedLiteral: true });\n\n        return hexadecimalLiteralNode;\n    }\n\n    /**\n     * @param {string} literalValue\n     * @returns {Literal}\n     */\n    private static getRc4KeyLiteralNode (literalValue: string): ESTree.Literal {\n        const rc4KeyLiteralNode: ESTree.Literal = NodeFactory.literalNode(literalValue);\n\n        NodeMetadata.set(rc4KeyLiteralNode, { replacedLiteral: true });\n\n        return rc4KeyLiteralNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: string): ESTree.Node {\n        if (this.isReservedString(nodeValue)) {\n            return this.replaceWithReservedLiteralNode(nodeValue);\n        }\n\n        const useStringArray: boolean = this.canUseStringArray(nodeValue);\n        const cacheKey: string = `${nodeValue}-${String(useStringArray)}`;\n        const useCacheValue: boolean = this.nodesCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.Rc4;\n\n        if (useCacheValue) {\n            return <ESTree.Node>this.nodesCache.get(cacheKey);\n        }\n\n        const resultNode: ESTree.Node = useStringArray\n            ? this.replaceWithStringArrayCallNode(nodeValue)\n            : this.replaceWithLiteralNode(nodeValue);\n\n        this.nodesCache.set(cacheKey, resultNode);\n\n        return resultNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {boolean}\n     */\n    private canUseStringArray (nodeValue: string): boolean {\n        return (\n            this.options.stringArray &&\n            nodeValue.length >= StringLiteralObfuscatingReplacer.minimumLengthForStringArray &&\n            this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} stringArrayStorageLength\n     * @returns {IStringArrayIndexData}\n     */\n    private getStringArrayHexadecimalIndex (value: string, stringArrayStorageLength: number): IStringArrayIndexData {\n        if (this.stringLiteralHexadecimalIndexCache.has(value)) {\n            return {\n                fromCache: true,\n                index: <string>this.stringLiteralHexadecimalIndexCache.get(value)\n            };\n        }\n\n        const hexadecimalRawIndex: string = NumberUtils.toHex(stringArrayStorageLength);\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${hexadecimalRawIndex}`;\n\n        this.stringLiteralHexadecimalIndexCache.set(value, hexadecimalIndex);\n\n        return {\n            fromCache: false,\n            index: hexadecimalIndex\n        };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string;\n        let key: string | null = null;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                key = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = this.cryptUtils.btoa(this.cryptUtils.rc4(value, key));\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                encodedValue = this.cryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        return { encodedValue, key };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, this.options.unicodeEscapeSequence)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithReservedLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, false)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithStringArrayCallNode (value: string): ESTree.Node {\n        const { encodedValue, key }: IEncodedValue = this.getEncodedValue(value);\n        const escapedValue: string = this.escapeSequenceEncoder.encode(encodedValue, this.options.unicodeEscapeSequence);\n\n        const stringArrayStorageLength: number = this.stringArrayStorage.getLength();\n        const stringArrayStorageCallsWrapperName: string = this.stringArrayStorage.getStorageId().split('|')[1];\n\n        const { fromCache, index }: IStringArrayIndexData = this.getStringArrayHexadecimalIndex(\n            escapedValue,\n            stringArrayStorageLength\n        );\n\n        if (!fromCache) {\n            this.stringArrayStorage.set(stringArrayStorageLength, escapedValue);\n        }\n\n        const callExpressionArgs: (ESTree.Expression | ESTree.SpreadElement)[] = [\n            StringLiteralObfuscatingReplacer.getHexadecimalLiteralNode(index)\n        ];\n\n        if (key) {\n            callExpressionArgs.push(StringLiteralObfuscatingReplacer.getRc4KeyLiteralNode(\n                this.escapeSequenceEncoder.encode(key, this.options.unicodeEscapeSequence)\n            ));\n        }\n\n        const stringArrayIdentifierNode: ESTree.Identifier = NodeFactory.identifierNode(stringArrayStorageCallsWrapperName);\n\n        // prevent obfuscation of this identifier\n        NodeMetadata.set(stringArrayIdentifierNode, { renamedIdentifier: true });\n\n        return NodeFactory.callExpressionNode(\n            stringArrayIdentifierNode,\n            callExpressionArgs\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {boolean}\n     */\n    private isReservedString (value: string): boolean {\n        if (!this.options.reservedStrings.length) {\n            return false;\n        }\n\n        return this.options.reservedStrings\n            .some((reservedString: string) => {\n                return new RegExp(reservedString, 'g').exec(value) !== null;\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeBlockLexicalScopeUtils } from '../../node/NodeBlockLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\n@injectable()\nexport class VariableDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {TReplaceableIdentifiers}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isVariableDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = variableDeclarationNode.kind === 'var'\n            ? NodeLexicalScopeUtils.getLexicalScope(variableDeclarationNode)\n            : NodeBlockLexicalScopeUtils.getLexicalScope(variableDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return variableDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return variableDeclarationNode;\n        }\n\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? lexicalScopeNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(scopeNode)) {\n            this.replaceScopeCachedIdentifiers(variableDeclarationNode, lexicalScopeNode, scopeNode);\n        } else {\n            this.replaceScopeIdentifiers(scopeNode, lexicalScopeNode);\n        }\n\n        return variableDeclarationNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeVariableNames (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            if (isGlobalDeclaration) {\n                this.identifierObfuscatingReplacer.storeGlobalName(identifierNode.name, lexicalScopeNode);\n            } else {\n                this.identifierObfuscatingReplacer.storeLocalName(identifierNode.name, lexicalScopeNode);\n            }\n        });\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Node} scopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        scopeNode: ESTree.Node\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(scopeNode);\n\n        const identifierNames: string[] = [];\n\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            identifierNames.push(identifierNode.name);\n        });\n\n        identifierNames.forEach((identifierName: string) => {\n            const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined =\n                cachedReplaceableIdentifiersNamesMap.get(identifierName);\n\n            if (!cachedReplaceableIdentifiers) {\n                return;\n            }\n\n            const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n            for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n                const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n\n                if (identifierName !== replaceableIdentifier.name) {\n                    continue;\n                }\n\n                const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                    .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n                replaceableIdentifier.name = newReplaceableIdentifier.name;\n                NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n            }\n        });\n    }\n\n    /**\n     * @param {Node} scopeNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (scopeNode: ESTree.Node, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(scopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {(identifier: Identifier) => void} callback\n     */\n    private traverseDeclarationIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        callback: (identifier: ESTree.Identifier) => void\n    ): void {\n        variableDeclarationNode.declarations\n            .forEach((declarationNode: ESTree.VariableDeclarator) => {\n                estraverse.traverse(declarationNode.id, {\n                    enter: (node: ESTree.Node) => {\n                        if (NodeGuards.isPropertyNode(node)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            callback(node);\n                        }\n                    }\n                });\n            });\n    }\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeBlockLexicalScopeUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope}\n     */\n    public static getLexicalScope (node: ESTree.Node): TNodeWithLexicalScope | undefined {\n        return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    public static getLexicalScopes (node: ESTree.Node): TNodeWithLexicalScope[] {\n        return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(node);\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithLexicalScope[]} nodesWithLexicalScope\n     * @param {number} depth\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    private static getLexicalScopesRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithLexicalScope: TNodeWithLexicalScope[] = [],\n        depth: number = 0\n    ): TNodeWithLexicalScope[] {\n        if (nodesWithLexicalScope.length >= maxSize) {\n            return nodesWithLexicalScope;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (NodeGuards.isNodeWithBlockLexicalScope(node)) {\n            nodesWithLexicalScope.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(parentNode, maxSize, nodesWithLexicalScope, ++depth);\n        }\n\n        return nodesWithLexicalScope;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../../../interfaces/options/IOptionsNormalizer';\n\nimport { Options } from '../../../options/Options';\nimport { OptionsNormalizer } from '../../../options/OptionsNormalizer';\n\nexport const optionsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IOptions>(ServiceIdentifiers.IOptions)\n        .to(Options)\n        .inSingletonScope();\n\n    bind<IOptionsNormalizer>(ServiceIdentifiers.IOptionsNormalizer)\n        .to(OptionsNormalizer)\n        .inSingletonScope();\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport {\n    ArrayUnique,\n    IsArray,\n    IsBoolean,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Max,\n    Min,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { IdentifierNamesGenerator } from '../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static readonly validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly deadCodeInjection!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly deadCodeInjectionThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock!: string[];\n\n    /**\n     * @type {IdentifierNamesGenerator}\n     */\n    @IsIn([\n        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n    ])\n    public readonly identifierNamesGenerator!: IdentifierNamesGenerator;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly identifiersPrefix!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly inputFileName!: string;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly log!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly renameGlobals!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames!: string[];\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedStrings!: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly seed!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap!: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_tld: false,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName!: string;\n\n    /**\n     * @type {SourceMapMode}\n     */\n    @IsIn([SourceMapMode.Inline, SourceMapMode.Separate])\n    public readonly sourceMapMode!: SourceMapMode;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray!: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, StringArrayEncoding.Base64, StringArrayEncoding.Rc4])\n    public readonly stringArrayEncoding!: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold!: number;\n\n    /**\n     * @type {ObfuscationTarget}\n     */\n    @IsIn([ObfuscationTarget.Browser, ObfuscationTarget.BrowserNoEval, ObfuscationTarget.Node])\n    public readonly target!: ObfuscationTarget;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly transformObjectKeys!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence!: boolean;\n\n    /**\n     * @param {TInputOptions} inputOptions\n     * @param {IOptionsNormalizer} optionsNormalizer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TInputOptions) inputOptions: TInputOptions,\n        @inject(ServiceIdentifiers.IOptionsNormalizer) optionsNormalizer: IOptionsNormalizer\n    ) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, optionsNormalizer.normalize(this));\n    }\n}\n","module.exports = require(\"class-validator\");","import { ValidationError } from 'class-validator';\n\nimport { TObject } from '../types/TObject';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param {ValidationError[]} errors\n     * @returns {string}\n     */\n    public static format (errors: ValidationError[]): string {\n        return errors\n            .reduce(\n                (errorMessages: string[], error: ValidationError) => ([\n                    ...errorMessages,\n                    ValidationErrorsFormatter.formatWithNestedConstraints(error)\n                ]),\n                []\n            )\n            .join('\\n');\n    }\n\n    /**\n     * @param {ValidationError} error\n     * @returns {string}\n     */\n    private static formatWithNestedConstraints (error: ValidationError): string {\n        const constraints: TObject<string> = error.constraints;\n\n        const rootError: string = `\\`${error.property}\\` errors:\\n`;\n        const nestedErrors: string = Object\n            .keys(constraints)\n            .map((constraint: string) => `    - ${constraints[constraint]}\\n`)\n            .join();\n\n        return `${rootError}${nestedErrors}`;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { ControlFlowFlatteningThresholdRule } from './normalizer-rules/ControlFlowFlatteningThresholdRule';\nimport { DeadCodeInjectionRule } from './normalizer-rules/DeadCodeInjectionRule';\nimport { DeadCodeInjectionThresholdRule } from './normalizer-rules/DeadCodeInjectionThresholdRule';\nimport { DomainLockRule } from './normalizer-rules/DomainLockRule';\nimport { InputFileNameRule } from './normalizer-rules/InputFileNameRule';\nimport { SelfDefendingRule } from './normalizer-rules/SelfDefendingRule';\nimport { SourceMapBaseUrlRule } from './normalizer-rules/SourceMapBaseUrlRule';\nimport { SourceMapFileNameRule } from './normalizer-rules/SourceMapFileNameRule';\nimport { StringArrayRule } from './normalizer-rules/StringArrayRule';\nimport { StringArrayEncodingRule } from './normalizer-rules/StringArrayEncodingRule';\nimport { StringArrayThresholdRule } from './normalizer-rules/StringArrayThresholdRule';\n\n@injectable()\nexport class OptionsNormalizer implements IOptionsNormalizer {\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        ControlFlowFlatteningThresholdRule,\n        DeadCodeInjectionRule,\n        DeadCodeInjectionThresholdRule,\n        DomainLockRule,\n        InputFileNameRule,\n        SelfDefendingRule,\n        SourceMapBaseUrlRule,\n        SourceMapFileNameRule,\n        StringArrayRule,\n        StringArrayEncodingRule,\n        StringArrayThresholdRule,\n    ];\n\n    /**\n     * @param {IOptions} options\n     * @returns {IOptions}\n     */\n    public normalize (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n}\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const ControlFlowFlatteningThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.controlFlowFlatteningThreshold === 0) {\n        options = {\n            ...options,\n            controlFlowFlattening: false,\n            controlFlowFlatteningThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { DEFAULT_PRESET } from '../presets/Default';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjection) {\n        options = {\n            ...options,\n            deadCodeInjection: true,\n            stringArray: true\n        };\n\n        if (!options.stringArrayThreshold) {\n            options = {\n                ...options,\n                stringArray: true,\n                stringArrayThreshold: <number>DEFAULT_PRESET.stringArrayThreshold\n            };\n        }\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjectionThreshold === 0) {\n        options = {\n            ...options,\n            deadCodeInjection: false,\n            deadCodeInjectionThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { Utils } from '../../utils/Utils';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DomainLockRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.domainLock.length) {\n        const normalizedDomains: string[] = [];\n\n        for (const domain of options.domainLock) {\n            normalizedDomains.push(Utils.extractDomainFrom(domain));\n        }\n\n        options = {\n            ...options,\n            domainLock: normalizedDomains\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const InputFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { inputFileName } = options;\n\n    if (inputFileName) {\n        inputFileName = inputFileName\n            .replace(/^\\/+/, '')\n            .split('.')\n            .slice(0, -1)\n            .join('.') || inputFileName;\n\n        options = {\n            ...options,\n            inputFileName: `${inputFileName}.js`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SelfDefendingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.selfDefending) {\n        options = {\n            ...options,\n            compact: true,\n            selfDefending: true\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapBaseUrlRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n    if (!options.sourceMapFileName) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: ''\n        };\n\n        return options;\n    }\n\n    if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n    if (sourceMapFileName) {\n        sourceMapFileName = sourceMapFileName\n            .replace(/^\\/+/, '')\n            .split('.')[0];\n\n        options = {\n            ...options,\n            sourceMapFileName: `${sourceMapFileName}.js.map`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (!options.stringArray) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayEncodingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayEncoding === true) {\n        options = {\n            ...options,\n            stringArrayEncoding: StringArrayEncoding.Base64\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayThreshold === 0) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { ObfuscatingGuard } from '../../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\n\nimport { BlackListObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard';\nimport { CommentsTransformer } from '../../../node-transformers/preparing-transformers/CommentsTransformer';\nimport { ConditionalCommentObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard';\nimport { CustomNodesTransformer } from '../../../node-transformers/preparing-transformers/CustomNodesTransformer';\nimport { EvalCallExpressionTransformer } from '../../../node-transformers/preparing-transformers/EvaCallExpressionTransformer';\nimport { MetadataTransformer } from '../../../node-transformers/preparing-transformers/MetadataTransformer';\nimport { ObfuscatingGuardsTransformer } from '../../../node-transformers/preparing-transformers/ObfuscatingGuardsTransformer';\nimport { ParentificationTransformer } from '../../../node-transformers/preparing-transformers/ParentificationTransformer';\nimport { VariablePreserveTransformer } from \"../../../node-transformers/preparing-transformers/VariablePreserveTransformer\";\n\nexport const preparingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // preparing transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CommentsTransformer)\n        .whenTargetNamed(NodeTransformer.CommentsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CustomNodesTransformer)\n        .whenTargetNamed(NodeTransformer.CustomNodesTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(EvalCallExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.EvalCallExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MetadataTransformer)\n        .whenTargetNamed(NodeTransformer.MetadataTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObfuscatingGuardsTransformer)\n        .whenTargetNamed(NodeTransformer.ObfuscatingGuardsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ParentificationTransformer)\n        .whenTargetNamed(NodeTransformer.ParentificationTransformer);\n\n    // obfuscating guards\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(BlackListObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.BlackListNodeGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ConditionalCommentObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ConditionalCommentNodeGuard);\n\n    // obfuscating guards factory\n    bind<IObfuscatingGuard>(ServiceIdentifiers.Factory__INodeGuard)\n        .toFactory<IObfuscatingGuard>(InversifyContainerFacade\n            .getCacheFactory<ObfuscatingGuard, IObfuscatingGuard>(\n                ServiceIdentifiers.INodeGuard\n            ));\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariablePreserveTransformer)\n        .whenTargetNamed(NodeTransformer.VariablePreserveTransformer);\n});\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeGuard } from '../../../types/node/TNodeGuard';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BlackListObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {((node: Node) => boolean)[]}\n     */\n    private static readonly blackListGuards: TNodeGuard[] = [\n        NodeGuards.isUseStrictOperator\n    ];\n\n    /**\n     * @type {number}\n     */\n    private readonly blackListGuardsLength: number;\n\n    constructor () {\n        this.blackListGuardsLength = BlackListObfuscatingGuard.blackListGuards.length;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        for (let i: number = 0; i < this.blackListGuardsLength; i++) {\n            if (BlackListObfuscatingGuard.blackListGuards[i](node)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport * as estraverse from \"estraverse\";\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { ConditionalCommentObfuscatingGuard } from \"./obfuscating-guards/ConditionalCommentObfuscatingGuard\";\n\n@injectable()\nexport class CommentsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly preservedWords: string[] = [\n        '@license',\n        '@preserve'\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Initializing:\n                return {\n                    leave: (node: ESTree.Node) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            return this.transformNode(node);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Removes all comments from node except comments that contain\n     * `@license`, `@preserve` or `javascript-obfuscator` words\n     * Move comments to their nodes\n     *\n     * @param {Node} programNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (programNode: ESTree.Program): ESTree.Node {\n        if (programNode.comments) {\n            const comments: ESTree.Comment[] = this.transformComments(programNode.comments);\n            estraverse.traverse(programNode, {\n                enter: (node: ESTree.Node): void => {\n                    if (comments.length === 0) {\n                        return;\n                    }\n\n                    const commentIdx: number = comments.findIndex((comment: ESTree.Comment) =>\n                        comment.range && node.range && comment.range[0] < node.range[0]\n                    );\n\n                    if (commentIdx === -1) {\n                        return;\n                    }\n\n                    node.leadingComments = comments.splice(commentIdx, comments.length - commentIdx).reverse();\n                }\n            });\n            if (comments.length > 0) {\n                programNode.trailingComments = comments.reverse();\n            }\n        }\n\n        return programNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {Comment[]}\n     */\n    private transformComments (comments: ESTree.Comment[]): ESTree.Comment[] {\n        return comments.filter((comment: ESTree.Comment) =>\n            CommentsTransformer.preservedWords\n                .some((preservedWord: string) => comment.value.includes(preservedWord)) ||\n            ConditionalCommentObfuscatingGuard.isConditionalComment(comment)\n        ).reverse();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeGroupStorage } from '../../types/storages/TCustomNodeGroupStorage';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from '../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Analyzing AST-tree and appending custom nodes\n */\n@injectable()\nexport class CustomNodesTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TCustomNodeGroupStorage}\n     */\n    private readonly customNodeGroupStorage: TCustomNodeGroupStorage;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {IStackTraceAnalyzer}\n     */\n    private readonly stackTraceAnalyzer: IStackTraceAnalyzer;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    private stackTraceData: IStackTraceData[] = [];\n\n    /**\n     * @param {IStackTraceAnalyzer} stackTraceAnalyzer\n     * @param {IObfuscationEventEmitter} obfuscationEventEmitter\n     * @param {TCustomNodeGroupStorage} customNodeGroupStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IStackTraceAnalyzer) stackTraceAnalyzer: IStackTraceAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: TCustomNodeGroupStorage,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.stackTraceAnalyzer = stackTraceAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n                            this.appendCustomNodesBeforeObfuscation(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.appendCustomNodesAfterObfuscation(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    public analyzeNode (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.stackTraceData = this.stackTraceAnalyzer.analyze(node);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Program, parentNode: ESTree.Node | null): ESTree.Node {\n        return node;\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesBeforeObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.BeforeObfuscation, node, this.stackTraceData);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesAfterObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.AfterObfuscation, node, this.stackTraceData);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport jsStringEscape from 'js-string-escape';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class EvalCallExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Set <FunctionExpression>}\n     */\n    private readonly evalRootAstHostNodeSet: Set <ESTree.FunctionExpression> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Expression | SpreadElement} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromCallExpressionArgument (node: ESTree.Expression | ESTree.SpreadElement): string | null {\n        if (NodeGuards.isLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromLiteralNode(node);\n        }\n\n        if (NodeGuards.isTemplateLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromTemplateLiteralNode(node);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Literal} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromLiteralNode (node: ESTree.Literal): string | null {\n        return typeof node.value === 'string' ? node.value : null;\n    }\n\n    /**\n     * @param {TemplateLiteral} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromTemplateLiteralNode (node: ESTree.TemplateLiteral): string | null {\n        const quasis: ESTree.TemplateElement[] = node.quasis;\n        const allowedQuasisLength: number = 1;\n\n        if (quasis.length !== allowedQuasisLength || node.expressions.length) {\n            return null;\n        }\n\n        return quasis[0].value.cooked;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isCallExpressionNode(node)\n                            && NodeGuards.isIdentifierNode(node.callee)\n                            && node.callee.name === 'eval'\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.evalRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isEvalRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (callExpressionNode: ESTree.CallExpression, parentNode: ESTree.Node): ESTree.Node {\n        const callExpressionFirstArgument: ESTree.Expression | ESTree.SpreadElement = callExpressionNode.arguments[0];\n\n        if (!callExpressionFirstArgument) {\n            return callExpressionNode;\n        }\n\n        const evalString: string | null = EvalCallExpressionTransformer\n            .extractEvalStringFromCallExpressionArgument(callExpressionFirstArgument);\n\n        if (!evalString) {\n            return callExpressionNode;\n        }\n\n        let ast: ESTree.Statement[];\n\n        // wrapping into try-catch to prevent parsing of incorrect `eval` string\n        try {\n            ast = NodeUtils.convertCodeToStructure(evalString);\n        } catch {\n            return callExpressionNode;\n        }\n\n        /**\n         * we should wrap AST-tree into the parent function expression node (ast root host node).\n         * This function expression node will help to correctly transform AST-tree.\n         */\n        const evalRootAstHostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], NodeFactory.blockStatementNode(ast));\n\n        /**\n         * we should store that host node and then extract AST-tree on the `finalizing` stage\n         */\n        this.evalRootAstHostNodeSet.add(evalRootAstHostNode);\n\n        return evalRootAstHostNode;\n    }\n\n    /**\n     * @param {FunctionExpression} evalRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (evalRootAstHostNode: ESTree.FunctionExpression, parentNode: ESTree.Node): ESTree.Node {\n        const targetAst: ESTree.Statement[] = evalRootAstHostNode.body.body;\n        const obfuscatedCode: string = NodeUtils.convertStructureToCode(targetAst);\n\n        return NodeFactory.callExpressionNode(\n            NodeFactory.identifierNode('eval'),\n            [\n                NodeFactory.literalNode(jsStringEscape(obfuscatedCode))\n            ]\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isEvalRootAstHostNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return NodeGuards.isFunctionExpressionNode(node) && this.evalRootAstHostNodeSet.has(node);\n    }\n}\n","module.exports = require(\"js-string-escape\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds metadata properties to each node\n */\n@injectable()\nexport class MetadataTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        NodeMetadata.set(node, { ignoredNode: false });\n\n        if (NodeGuards.isIdentifierNode(node)) {\n            NodeMetadata.set(node, { renamedIdentifier: false });\n        }\n\n        if (NodeGuards.isLiteralNode(node)) {\n            NodeMetadata.set(node, { replacedLiteral: false });\n        }\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TObfuscatingGuardFactory } from '../../types/container/node-transformers/TObfuscatingGuardFactory';\n\nimport { IObfuscatingGuard } from '../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscatingGuard } from '../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds `ignoredNode` properties to each node\n */\n@injectable()\nexport class ObfuscatingGuardsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {ObfuscatingGuard[]}\n     */\n    private static readonly obfuscatingGuardsList: ObfuscatingGuard[] = [\n        ObfuscatingGuard.BlackListNodeGuard,\n        ObfuscatingGuard.ConditionalCommentNodeGuard\n    ];\n\n    /**\n     * @type {IObfuscatingGuard[]}\n     */\n    private readonly obfuscatingGuards: IObfuscatingGuard[];\n\n    /**\n     * @param {TObfuscatingGuardFactory} obfuscatingGuardFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeGuard) obfuscatingGuardFactory: TObfuscatingGuardFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.obfuscatingGuards = ObfuscatingGuardsTransformer.obfuscatingGuardsList.map(obfuscatingGuardFactory);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        const obfuscationAllowed: boolean = this.obfuscatingGuards\n            .every((nodeGuard: IObfuscatingGuard) => nodeGuard.check(node));\n\n        NodeMetadata.set(node, {\n            ignoredNode: !obfuscationAllowed\n        });\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Adds `parentNode` properties to each node\n */\n@injectable()\nexport class ParentificationTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        return NodeUtils.parentizeNode(node, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\n\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Preserve non-replaceable variables\n */\n@injectable()\nexport class VariablePreserveTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            NodeGuards.isIdentifierNode(node)\n                            && parentNode\n                            && (\n                                NodeGuards.parentNodeIsPropertyNode(node, parentNode)\n                                || NodeGuards.parentNodeIsMemberExpressionNode(node, parentNode)\n                                || NodeGuards.parentNodeIsMethodDefinitionNode(node, parentNode)\n                                || NodeGuards.isLabelIdentifierNode(node, parentNode)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Identifier} node\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (node: ESTree.Identifier, parentNode: ESTree.Node): ESTree.Node {\n        this.identifierObfuscatingReplacer.preserveName(node.name);\n\n        return node;\n    }\n\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<TStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n                const randomGenerator: IRandomGenerator = context.container\n                    .get<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator);\n                const options: IOptions = context.container\n                    .get<IOptions>(ServiceIdentifiers.IOptions);\n\n                const storage: TControlFlowStorage = new constructor(randomGenerator, options);\n\n                storage.initialize();\n\n                return storage;\n            };\n        });\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class ControlFlowStorage extends MapStorage <string, ICustomNode> {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/custom-nodes/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { CustomNodeGroup } from '../../enums/custom-nodes/CustomNodeGroup';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <string, ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroup[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroup[] = [\n        CustomNodeGroup.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroup.DebugProtectionCustomNodeGroup,\n        CustomNodeGroup.DomainLockCustomNodeGroup,\n        CustomNodeGroup.SelfDefendingCustomNodeGroup,\n        CustomNodeGroup.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @param {TCustomNodeGroupFactory} customNodeGroupFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroup) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ArrayStorage } from '../ArrayStorage';\n\n@injectable()\nexport class StringArrayStorage extends ArrayStorage <string> {\n    /**\n     * @type {number}\n     */\n    private static readonly stringArrayNameLength: number = 7;\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.arrayUtils = arrayUtils;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        const baseStringArrayName: string = this.identifierNamesGenerator\n            .generate(StringArrayStorage.stringArrayNameLength);\n        const baseStringArrayCallsWrapperName: string = this.identifierNamesGenerator\n            .generate(StringArrayStorage.stringArrayNameLength);\n        const stringArrayName: string = `${this.options.identifiersPrefix}${baseStringArrayName}`;\n        const stringArrayCallsWrapperName: string = `${this.options.identifiersPrefix}${baseStringArrayCallsWrapperName}`;\n\n        this.storageId = `${stringArrayName}|${stringArrayCallsWrapperName}`;\n    }\n\n    /**\n     * @param {number} rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.storage = this.arrayUtils.rotate(this.storage, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.storage.map((value: string) => {\n            return `'${value}'`;\n        }).toString();\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayStorage } from '../interfaces/storages/IArrayStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class ArrayStorage <V> implements IArrayStorage <V> {\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {V[]}\n     */\n    @initializable()\n    protected storage!: V[];\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {number}\n     */\n    private storageLength: number = 0;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = [];\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {number} key\n     * @returns {V}\n     */\n    public get (key: number): V {\n        const value: V | undefined = this.storage[key];\n\n        if (!value) {\n            throw new Error(`No value found in array storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {number}\n     */\n    public getKeyOf (value: V): number | null {\n        const key: number = this.storage.indexOf(value);\n\n        return key >= 0 ? key : null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storageLength;\n    }\n\n    /**\n     * @returns {V[]}\n     */\n    public getStorage (): V[] {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = [...this.storage, ...storage.getStorage()];\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {number} key\n     * @param {V} value\n     */\n    public set (key: number, value: V): void {\n        if (key === this.storageLength) {\n            this.storage.push(value);\n        } else {\n            this.storage.splice(key, 0, value);\n        }\n\n        this.storageLength++;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../../interfaces/utils/ICryptUtils';\nimport { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ArrayUtils } from '../../../utils/ArrayUtils';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { EscapeSequenceEncoder } from '../../../utils/EscapeSequenceEncoder';\nimport { RandomGenerator } from '../../../utils/RandomGenerator';\n\nexport const utilsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // array utils\n    bind<IArrayUtils>(ServiceIdentifiers.IArrayUtils)\n        .to(ArrayUtils)\n        .inSingletonScope();\n\n    // random generator\n    bind<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator)\n        .to(RandomGenerator)\n        .inSingletonScope();\n\n    // crypt utils\n    bind<ICryptUtils>(ServiceIdentifiers.ICryptUtils)\n        .to(CryptUtils)\n        .inSingletonScope();\n\n    // escape sequence encoder\n    bind<IEscapeSequenceEncoder>(ServiceIdentifiers.IEscapeSequenceEncoder)\n        .to(EscapeSequenceEncoder)\n        .inSingletonScope();\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport class ArrayUtils implements IArrayUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param {number} length\n     * @returns {number[]}\n     */\n    public createWithRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param {T[]} array\n     * @param {number} times\n     * @returns {T[]}\n     */\n    public rotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop();\n\n            if (temp) {\n                newArray.unshift(temp);\n            }\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T[]}\n     */\n    public shuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(this.randomGenerator.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { RandomGenerator } from './RandomGenerator';\nimport { Utils } from './Utils';\n\n@injectable()\nexport class CryptUtils implements ICryptUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    // tslint:disable\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number | undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    // tslint:enable\n\n    /**\n     * Hides string inside a other random string with larger length\n     *\n     * @param {string} str\n     * @param {number} length\n     * @returns {[string , string]}\n     */\n    public hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = (s1: string, s2: string): string => {\n            let i1: number = -1;\n            let i2: number = -1;\n            let result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (this.randomGenerator.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = this.randomGenerator.getRandomGenerator().string({\n            length: length,\n            pool: RandomGenerator.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp(`[${escapeRegExp(str)}]`, 'g'),\n            ''\n        );\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        this.randomGenerator.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n    }\n\n    // tslint:disable\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param {string} string\n     * @param {string} key\n     * @returns {string}\n     */\n    public rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    // tslint:enable\n}\n","module.exports = require(\"md5\");","module.exports = require(\"chance\");","import { injectable } from 'inversify';\n\nimport { IEscapeSequenceEncoder } from '../interfaces/utils/IEscapeSequenceEncoder';\n\n@injectable()\nexport class EscapeSequenceEncoder implements IEscapeSequenceEncoder {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringsCache: Map <string, string> = new Map();\n\n    /**\n     * @param {string} string\n     * @param {boolean} encodeAllSymbols\n     * @returns {string}\n     */\n    public encode (string: string, encodeAllSymbols: boolean): string {\n        const cacheKey: string = `${string}-${String(encodeAllSymbols)}`;\n\n        if (this.stringsCache.has(cacheKey)) {\n            return <string>this.stringsCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeSequenceRegExp: RegExp = new RegExp('[\\'\\\"\\\\\\\\\\\\s]');\n        const regExp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string;\n        let template: string;\n\n        const result: string = string.replace(replaceRegExp, (character: string): string => {\n            if (!encodeAllSymbols && !escapeSequenceRegExp.exec(character)) {\n                return character;\n            }\n\n            if (regExp.exec(character)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + character.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        this.stringsCache.set(cacheKey, result);\n\n        return result;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport { TObfuscatedCodeFactory } from './types/container/source-code/TObfuscatedCodeFactory';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { ILogger } from './interfaces/logger/ILogger';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IRandomGenerator } from './interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from './interfaces/node-transformers/ITransformersRunner';\n\nimport { LoggingMessage } from './enums/logger/LoggingMessage';\nimport { NodeTransformer } from './enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from './enums/node-transformers/TransformationStage';\n\nimport { EspreeFacade } from './EspreeFacade';\nimport { NodeGuards } from './node/NodeGuards';\n\n@injectable()\nexport class JavaScriptObfuscator implements IJavaScriptObfuscator {\n    /**\n     * @type {Options}\n     */\n    private static readonly espreeParseOptions: espree.ParseOptions = {\n        comment: true,\n        ecmaVersion: 10,\n        loc: true,\n        range: true\n    };\n\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        comment: true,\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersList: NodeTransformer[] = [\n        NodeTransformer.BlockStatementControlFlowTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.CommentsTransformer,\n        NodeTransformer.CustomNodesTransformer,\n        NodeTransformer.DeadCodeInjectionTransformer,\n        NodeTransformer.EvalCallExpressionTransformer,\n        NodeTransformer.FunctionControlFlowTransformer,\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.ImportDeclarationTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.LiteralTransformer,\n        NodeTransformer.MemberExpressionTransformer,\n        NodeTransformer.MetadataTransformer,\n        NodeTransformer.MethodDefinitionTransformer,\n        NodeTransformer.ObfuscatingGuardsTransformer,\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.ObjectExpressionTransformer,\n        NodeTransformer.ParentificationTransformer,\n        NodeTransformer.TemplateLiteralTransformer,\n        NodeTransformer.VariableDeclarationTransformer,\n        NodeTransformer.VariablePreserveTransformer\n    ];\n\n    /**\n     * @type {ILogger}\n     */\n    private readonly logger: ILogger;\n\n    /**\n     * @type {TObfuscatedCodeFactory}\n     */\n    private readonly obfuscatedCodeFactory: TObfuscatedCodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {TObfuscatedCodeFactory} obfuscatedCodeFactory\n     * @param {ILogger} logger\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.Factory__IObfuscatedCode) obfuscatedCodeFactory: TObfuscatedCodeFactory,\n        @inject(ServiceIdentifiers.ILogger) logger: ILogger,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.transformersRunner = transformersRunner;\n        this.randomGenerator = randomGenerator;\n        this.obfuscatedCodeFactory = obfuscatedCodeFactory;\n        this.logger = logger;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {IObfuscatedCode}\n     */\n    public obfuscate (sourceCode: string): IObfuscatedCode {\n        const timeStart: number = Date.now();\n        this.logger.info(LoggingMessage.Version, process.env.VERSION);\n        this.logger.info(LoggingMessage.ObfuscationStarted);\n        this.logger.info(LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getSeed());\n\n        // parse AST tree\n        const astTree: ESTree.Program = this.parseCode(sourceCode);\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.transformAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        const obfuscationTime: number = (Date.now() - timeStart) / 1000;\n        this.logger.success(LoggingMessage.ObfuscationCompleted, obfuscationTime);\n\n        return this.getObfuscatedCode(generatorOutput);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {Program}\n     */\n    private parseCode (sourceCode: string): ESTree.Program {\n        return EspreeFacade.parse(sourceCode, JavaScriptObfuscator.espreeParseOptions);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {Program}\n     */\n    private transformAstTree (astTree: ESTree.Program): ESTree.Program {\n        astTree = this.runTransformationStage(astTree, TransformationStage.Initializing);\n\n        const isEmptyAstTree: boolean = NodeGuards.isProgramNode(astTree)\n            && !astTree.body.length\n            && !astTree.leadingComments\n            && !astTree.trailingComments;\n\n        if (isEmptyAstTree) {\n            this.logger.warn(LoggingMessage.EmptySourceCode);\n\n            return astTree;\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Preparing);\n\n        if (this.options.deadCodeInjection) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.DeadCodeInjection);\n        }\n\n        if (this.options.controlFlowFlattening) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.ControlFlowFlattening);\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Converting);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Obfuscating);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Finalizing);\n\n        return astTree;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {Program} astTree\n     * @returns {IGeneratorOutput}\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscator.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = this.options.inputFileName || 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, {\n            ...escodegenParams,\n            format: {\n                compact: this.options.compact\n            }\n        });\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param {IGeneratorOutput} generatorOutput\n     * @returns {IObfuscatedCode}\n     */\n    private getObfuscatedCode (generatorOutput: IGeneratorOutput): IObfuscatedCode {\n        return this.obfuscatedCodeFactory(generatorOutput.code, generatorOutput.map);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @param {TransformationStage} transformationStage\n     * @returns {Program}\n     */\n    private runTransformationStage (astTree: ESTree.Program, transformationStage: TransformationStage): ESTree.Program {\n        this.logger.info(LoggingMessage.TransformationStage, transformationStage);\n\n        return this.transformersRunner.transform(\n            astTree,\n            JavaScriptObfuscator.transformersList,\n            transformationStage\n        );\n    }\n}\n","export enum LoggingMessage {\n    EmptySourceCode = 'Empty source code. Obfuscation canceled...',\n    ObfuscationCompleted = 'Obfuscation completed. Total time: %s sec.',\n    ObfuscationStarted = 'Obfuscation started...',\n    RandomGeneratorSeed = 'Random generator seed: %s...',\n    TransformationStage = 'Transformation stage: %s...',\n    Version = 'Version: %s'\n}\n","import * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport chalk, { Chalk } from 'chalk';\n\n/**\n * Facade over `espree`\n */\nexport class EspreeFacade {\n    /**\n     * @type {Chalk}\n     */\n    private static readonly colorError: Chalk = chalk.red;\n\n    /**\n     * @type {number}\n     */\n    private static readonly nearestSymbolsCount: number = 15;\n\n    /**\n     * @type {SourceType[]}\n     */\n    private static readonly sourceTypes: espree.SourceType[] = [\n        'script',\n        'module'\n    ];\n\n    /**\n     * @param {string} input\n     * @param {Options} config\n     * @returns {Program}\n     */\n    public static parse (input: string, config: espree.ParseOptions): ESTree.Program | never {\n        const sourceTypeLength: number = EspreeFacade.sourceTypes.length;\n\n        for (let i: number = 0; i < sourceTypeLength; i++) {\n            try {\n                return EspreeFacade.parseType(input, config, EspreeFacade.sourceTypes[i]);\n            } catch (error) {\n                if (i < sourceTypeLength - 1) {\n                    continue;\n                }\n\n                throw new Error(EspreeFacade.processParsingError(\n                    input,\n                    error.message,\n                    {\n                        line: error.lineNumber,\n                        column: error.column,\n                    }\n                ));\n            }\n        }\n\n        throw new Error(`Espree parsing error`);\n    }\n\n    /**\n     * @param {string} input\n     * @param {ParseOptions} inputConfig\n     * @param {SourceType} sourceType\n     * @returns {Program}\n     */\n    private static parseType (\n        input: string,\n        inputConfig: espree.ParseOptions,\n        sourceType: espree.SourceType\n    ): ESTree.Program {\n        const config: espree.ParseOptions = { ...inputConfig, sourceType };\n\n        return espree.parse(input, config);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} errorMessage\n     * @param {Position} position\n     * @returns {never}\n     */\n    private static processParsingError (sourceCode: string, errorMessage: string, position: ESTree.Position | null): never {\n        if (!position || !position.line || !position.column) {\n            throw new Error(errorMessage);\n        }\n\n        const sourceCodeLines: string[] = sourceCode.split(/\\r?\\n/);\n        const errorLine: string | undefined = sourceCodeLines[position.line - 1];\n\n        if (!errorLine) {\n            throw new Error(errorMessage);\n        }\n\n        const startErrorIndex: number = Math.max(0, position.column - EspreeFacade.nearestSymbolsCount);\n        const endErrorIndex: number = Math.min(errorLine.length, position.column + EspreeFacade.nearestSymbolsCount);\n\n        const formattedPointer: string = EspreeFacade.colorError('>');\n        const formattedCodeSlice: string = `...${\n            errorLine.substring(startErrorIndex, endErrorIndex).replace(/^\\s+/, '')\n        }...`;\n\n        throw new Error(`Line ${position.line}: ${errorMessage}\\n${formattedPointer} ${formattedCodeSlice}`);\n    }\n}\n","import { decorate, injectable } from 'inversify';\nimport EventEmitter from 'eventemitter3';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n","module.exports = require(\"eventemitter3\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\n\nimport { initializable } from '../decorators/Initializable';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { IOptions } from '../interfaces/options/IOptions';\n\n@injectable()\nexport class ObfuscatedCode implements IObfuscatedCode {\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode!: string;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap!: string;\n\n    constructor (\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.cryptUtils = cryptUtils;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.correctObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    private correctObfuscatedCode (): string {\n        if (!this.sourceMap) {\n            return this.obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${this.cryptUtils.btoa(this.sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return this.obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n        }\n\n        return `${this.obfuscatedCode}\\n${sourceMappingUrl}`;\n    }\n}\n","import { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nexport class SourceCode implements ISourceCode {\n    /**\n     * @type {string}\n     */\n    private readonly sourceCode: string;\n\n    /**\n     * @type {string}\n     */\n    private readonly sourceMap: string;\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     */\n    constructor (sourceCode: string, sourceMap: string) {\n        this.sourceCode = sourceCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceCode (): string {\n        return this.sourceCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.sourceCode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from '../types/container/node-transformers/TNodeTransformerFactory';\nimport { TVisitorDirection } from '../types/node-transformers/TVisitorDirection';\nimport { TVisitorFunction } from '../types/node-transformers/TVisitorFunction';\nimport { TVisitorResult } from '../types/node-transformers/TVisitorResult';\n\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\nimport { VisitorDirection } from '../enums/node-transformers/VisitorDirection';\n\nimport { NodeGuards } from '../node/NodeGuards';\nimport { NodeMetadata } from '../node/NodeMetadata';\n\n@injectable()\nexport class TransformersRunner implements ITransformersRunner {\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @param {TNodeTransformerFactory} nodeTransformerFactory\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeTransformer) nodeTransformerFactory: TNodeTransformerFactory,\n    ) {\n        this.nodeTransformerFactory = nodeTransformerFactory;\n    }\n\n    /**\n     * @param {T} astTree\n     * @param {NodeTransformer[]} nodeTransformers\n     * @param {TransformationStage} transformationStage\n     * @returns {T}\n     */\n    public transform <T extends ESTree.Node = ESTree.Program> (\n        astTree: T,\n        nodeTransformers: NodeTransformer[],\n        transformationStage: TransformationStage\n    ): T {\n        if (!nodeTransformers.length) {\n            return astTree;\n        }\n\n        const enterVisitors: IVisitor[] = [];\n        const leaveVisitors: IVisitor[] = [];\n        const nodeTransformersLength: number = nodeTransformers.length;\n\n        let visitor: IVisitor | null;\n\n        for (let i: number = 0; i < nodeTransformersLength; i++) {\n            visitor = this.nodeTransformerFactory(nodeTransformers[i]).getVisitor(transformationStage);\n\n            if (!visitor) {\n                continue;\n            }\n\n            if (visitor.enter) {\n                enterVisitors.push({ enter: visitor.enter });\n            }\n\n            if (visitor.leave) {\n                leaveVisitors.push({ leave: visitor.leave });\n            }\n        }\n\n        if (!enterVisitors.length && !leaveVisitors.length) {\n            return astTree;\n        }\n\n        estraverse.replace(astTree, {\n            enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.Enter),\n            leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.Leave)\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {IVisitor[]} visitors\n     * @param {TVisitorDirection} direction\n     * @returns {TVisitorFunction}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        const visitorsLength: number = visitors.length;\n\n        if (!visitorsLength) {\n            return (node: ESTree.Node, parentNode: ESTree.Node | null) => node;\n        }\n\n        return (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n            if (NodeMetadata.isIgnoredNode(node)) {\n                return estraverse.VisitorOption.Skip;\n            }\n\n            for (let i: number = 0; i < visitorsLength; i++) {\n                const visitorFunction: TVisitorFunction | undefined = visitors[i][direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: TVisitorResult = visitorFunction(node, parentNode);\n\n                if (!visitorResult || !NodeGuards.isNode(visitorResult)) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n","export enum VisitorDirection {\n    Enter = 'enter',\n    Leave = 'leave'\n}\n","import * as commander from 'commander';\nimport * as path from 'path';\n\nimport { TInputCLIOptions } from '../types/options/TInputCLIOptions';\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TSourceCodeData } from '../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../interfaces/cli/IFileData';\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { DEFAULT_PRESET } from '../options/presets/Default';\n\nimport { ArraySanitizer } from './sanitizers/ArraySanitizer';\nimport { BooleanSanitizer } from './sanitizers/BooleanSanitizer';\nimport { IdentifierNamesGeneratorSanitizer } from './sanitizers/IdentifierNamesGeneratorSanitizer';\nimport { ObfuscationTargetSanitizer } from './sanitizers/ObfuscatingTargetSanitizer';\nimport { SourceMapModeSanitizer } from './sanitizers/SourceMapModeSanitizer';\nimport { StringArrayEncodingSanitizer } from './sanitizers/StringArrayEncodingSanitizer';\n\nimport { CLIUtils } from './utils/CLIUtils';\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscatorFacade';\nimport { SourceCodeReader } from './utils/SourceCodeReader';\n\nexport class JavaScriptObfuscatorCLI implements IInitializable {\n    /**\n     * @type {BufferEncoding}\n     */\n    public static readonly encoding: BufferEncoding = 'utf8';\n\n    /**\n     * @type {string}\n     */\n    public static obfuscatedFilePrefix: string = '-obfuscated';\n\n    /**\n     * @type {string}\n     */\n    private static readonly baseIdentifiersPrefix: string = 'a';\n\n    /**\n     * @type {string[]}\n     */\n    private readonly arguments: string[];\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rawArguments: string[];\n\n    /**\n     * @type {commander.CommanderStatic}\n     */\n    @initializable()\n    private commands!: commander.CommanderStatic;\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    @initializable()\n    private inputCLIOptions!: TInputCLIOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private inputPath!: string;\n\n    /**\n     * @param {string[]} argv\n     */\n    constructor (argv: string[]) {\n        this.rawArguments = argv;\n        this.arguments = argv.slice(2);\n    }\n\n    /**\n     * @param {TObject} options\n     * @returns {TInputOptions}\n     */\n    private static filterOptions (options: TInputCLIOptions): TInputOptions {\n        const filteredOptions: TInputOptions = {};\n\n        Object\n            .keys(options)\n            .forEach((option: keyof TInputCLIOptions) => {\n                if (options[option] === undefined) {\n                    return;\n                }\n\n                filteredOptions[option] = options[option];\n            });\n\n        return filteredOptions;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithoutSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const obfuscatedCode: string = JavaScriptObfuscator.obfuscate(sourceCode, options).getObfuscatedCode();\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const outputSourceMapPath: string = CLIUtils.getOutputSourceMapPath(\n            outputCodePath,\n            options.sourceMapFileName || ''\n        );\n\n        options = {\n            ...options,\n            sourceMapFileName: path.basename(outputSourceMapPath)\n        };\n\n        const obfuscatedCode: IObfuscatedCode = JavaScriptObfuscator.obfuscate(sourceCode, options);\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode.getObfuscatedCode());\n\n        if (options.sourceMapMode === 'separate' && obfuscatedCode.getSourceMap()) {\n            CLIUtils.writeFile(outputSourceMapPath, obfuscatedCode.getSourceMap());\n        }\n    }\n\n    public initialize (): void {\n        this.inputPath = path.normalize(this.arguments[0] || '');\n        this.commands = <commander.CommanderStatic>(new commander.Command());\n\n        this.configureCommands();\n        this.configureHelp();\n\n        this.inputCLIOptions = this.commands.opts();\n    }\n\n    public run (): void {\n        const canShowHelp: boolean = !this.arguments.length || this.arguments.includes('--help');\n\n        if (canShowHelp) {\n            this.commands.outputHelp();\n\n            return;\n        }\n\n        const sourceCodeData: TSourceCodeData = new SourceCodeReader(this.inputCLIOptions)\n            .readSourceCode(this.inputPath);\n\n        this.processSourceCodeData(sourceCodeData);\n    }\n\n    /**\n     * @returns {TInputOptions}\n     */\n    private buildOptions (): TInputOptions {\n        const inputCLIOptions: TInputOptions = JavaScriptObfuscatorCLI.filterOptions(this.inputCLIOptions);\n        const configFilePath: string | undefined = this.inputCLIOptions.config;\n        const configFileLocation: string = configFilePath ? path.resolve(configFilePath, '.') : '';\n        const configFileOptions: TInputOptions = configFileLocation ? CLIUtils.getUserConfig(configFileLocation) : {};\n        const inputFileName: string = path.basename(this.inputPath);\n\n        return {\n            ...DEFAULT_PRESET,\n            ...configFileOptions,\n            ...inputCLIOptions,\n            inputFileName\n        };\n    }\n\n    private configureCommands (): void {\n        this.commands\n            .usage('<inputPath> [options]')\n            .version(\n                process.env.VERSION || 'unknown',\n                '-v, --version'\n            )\n            .option(\n                '-o, --output <path>',\n                'Output path for obfuscated code'\n            )\n            .option(\n                '--compact <boolean>',\n                'Disable one line output code compacting',\n                BooleanSanitizer\n            )\n            .option(\n                '--config <boolean>',\n                'Name of js / json config file'\n            )\n            .option(\n                '--control-flow-flattening <boolean>',\n                'Enables control flow flattening',\n                BooleanSanitizer\n            )\n            .option(\n                '--control-flow-flattening-threshold <number>',\n                'The probability that the control flow flattening transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--dead-code-injection <boolean>',\n                'Enables dead code injection',\n                BooleanSanitizer\n            )\n            .option(\n                '--dead-code-injection-threshold <number>',\n                'The probability that the dead code injection transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--debug-protection <boolean>',\n                'Disable browser Debug panel (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--debug-protection-interval <boolean>',\n                'Disable browser Debug panel even after page was loaded (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--disable-console-output <boolean>',\n                'Allow console.log, console.info, console.error and console.warn messages output into browser console',\n                BooleanSanitizer\n            )\n            .option(\n                '--domain-lock <list> (comma separated, without whitespaces)',\n                'Blocks the execution of the code in domains that do not match the passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--exclude <list> (comma separated, without whitespaces)',\n                'A filename or glob which indicates files to exclude from obfuscation',\n                ArraySanitizer\n            )\n            .option(\n                '--identifier-names-generator <string>',\n                'Sets identifier names generator. ' +\n                'Values: hexadecimal, mangled. ' +\n                'Default: hexadecimal',\n                IdentifierNamesGeneratorSanitizer\n            )\n            .option(\n                '--identifiers-prefix <string>',\n                'Sets prefix for all global identifiers.'\n            )\n            .option(\n                '--log <boolean>', 'Enables logging of the information to the console',\n                BooleanSanitizer\n            )\n            .option(\n                '--reserved-names <list> (comma separated, without whitespaces)',\n                'Disables obfuscation and generation of identifiers, which being matched by passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--reserved-strings <list> (comma separated, without whitespaces)',\n                'Disables transformation of string literals, which being matched by passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--rename-globals <boolean>', 'Allows to enable obfuscation of global variable and function names with declaration.',\n                BooleanSanitizer\n            )\n            .option(\n                '--rotate-string-array <boolean>', 'Disable rotation of unicode array values during obfuscation',\n                BooleanSanitizer\n            )\n            .option(\n                '--seed <number>',\n                'Sets seed for random generator. This is useful for creating repeatable results.',\n                parseFloat\n            )\n            .option(\n                '--self-defending <boolean>',\n                'Disables self-defending for obfuscated code',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map <boolean>',\n                'Enables source map generation',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map-base-url <string>',\n                'Sets base url to the source map import url when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-file-name <string>',\n                'Sets file name for output source map when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-mode <string>',\n                'Specify source map output mode. ' +\n                'Values: inline, separate. ' +\n                'Default: separate',\n                SourceMapModeSanitizer\n            )\n            .option(\n                '--string-array <boolean>',\n                'Disables gathering of all literal strings into an array and replacing every literal string with an array call',\n                BooleanSanitizer\n            )\n            .option(\n                '--string-array-encoding <string|boolean>',\n                'Encodes all strings in strings array using base64 or rc4 (this option can slow down your code speed. ' +\n                'Values: true, false, base64, rc4. ' +\n                'Default: false',\n                StringArrayEncodingSanitizer\n            )\n            .option(\n                '--string-array-threshold <number>',\n                'The probability that the literal string will be inserted into stringArray (Default: 0.8, Min: 0, Max: 1)',\n                parseFloat\n            )\n            .option(\n                '--target <string>',\n                'Allows to set target environment for obfuscated code. ' +\n                'Values: browser, browser-no-eval, node. ' +\n                'Default: browser',\n                ObfuscationTargetSanitizer\n            )\n            .option(\n                '--transform-object-keys <boolean>',\n                'Enables transformation of object keys',\n                BooleanSanitizer\n            )\n            .option(\n                '--unicode-escape-sequence <boolean>',\n                'Allows to enable/disable string conversion to unicode escape sequence',\n                BooleanSanitizer\n            )\n            .parse(this.rawArguments);\n    }\n\n    private configureHelp (): void {\n        this.commands.on('--help', () => {\n            console.log('  Examples:\\n');\n            console.log('    %> javascript-obfuscator input_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_file_name.js --output output_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_directory_name --compact true --self-defending false');\n            console.log('');\n        });\n    }\n\n    /**\n     * @param {TSourceCodeData} sourceCodeData\n     */\n    private processSourceCodeData (sourceCodeData: TSourceCodeData): void {\n        const outputPath: string = this.inputCLIOptions.output\n            ? path.normalize(this.inputCLIOptions.output)\n            : '';\n\n        if (!Array.isArray(sourceCodeData)) {\n            const outputCodePath: string = outputPath || CLIUtils.getOutputCodePath(this.inputPath);\n\n            this.processSourceCode(sourceCodeData, outputCodePath, null);\n        } else {\n            sourceCodeData.forEach(({ filePath, content }: IFileData, index: number) => {\n                const outputCodePath: string = outputPath\n                    ? path.join(outputPath, filePath)\n                    : CLIUtils.getOutputCodePath(filePath);\n\n                this.processSourceCode(content, outputCodePath, index);\n            });\n        }\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {number | null} sourceCodeIndex\n     */\n    private processSourceCode (\n        sourceCode: string,\n        outputCodePath: string,\n        sourceCodeIndex: number | null\n    ): void {\n        let options: TInputOptions = this.buildOptions();\n\n        if (sourceCodeIndex !== null) {\n            const baseIdentifiersPrefix: string = this.inputCLIOptions.identifiersPrefix\n                || JavaScriptObfuscatorCLI.baseIdentifiersPrefix;\n            const identifiersPrefix: string = `${baseIdentifiersPrefix}${sourceCodeIndex}`;\n\n            options = {\n                ...options,\n                identifiersPrefix\n            };\n        }\n\n        if (options.sourceMap) {\n            JavaScriptObfuscatorCLI.processSourceCodeWithSourceMap(sourceCode, outputCodePath, options);\n        } else {\n            JavaScriptObfuscatorCLI.processSourceCodeWithoutSourceMap(sourceCode, outputCodePath, options);\n        }\n    }\n}\n","module.exports = require(\"path\");","module.exports = require(\"fs\");","\"use strict\";\n\nimport { JavaScriptObfuscatorCLI } from './src/JavaScriptObfuscatorCLIFacade';\n\nmodule.exports = JavaScriptObfuscatorCLI;\n","import 'reflect-metadata';\n\nimport { JavaScriptObfuscatorCLI } from './cli/JavaScriptObfuscatorCLI';\n\nclass JavaScriptObfuscatorCLIFacade {\n    /**\n     * @param {string[]} argv\n     */\n    public static obfuscate (argv: string[]): void {\n        const javaScriptObfuscatorCLI: JavaScriptObfuscatorCLI = new JavaScriptObfuscatorCLI(argv);\n\n        javaScriptObfuscatorCLI.initialize();\n        javaScriptObfuscatorCLI.run();\n    }\n}\n\nexport { JavaScriptObfuscatorCLIFacade as JavaScriptObfuscatorCLI };\n","module.exports = require(\"commander\");","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {string[]}\n */\nexport const ArraySanitizer: TCLISanitizer <string[]> = (value: string): string[] => {\n    if (/,$/.test(value)) {\n        throw new SyntaxError(`Multiple <list> values should be wrapped inside quotes: --option-name 'value1','value2'`);\n    }\n\n    return value.split(',').map((string: string) => string.trim());\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nexport const BooleanSanitizer: TCLISanitizer <boolean> = (value: string): boolean => {\n    return value === 'true' || value === '1';\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const IdentifierNamesGeneratorSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectIdentifierNamesGenerator: boolean = Object\n        .keys(IdentifierNamesGenerator)\n        .some((key: string): boolean => {\n            return IdentifierNamesGenerator[<keyof typeof IdentifierNamesGenerator>key] === value;\n        });\n\n    if (!isCorrectIdentifierNamesGenerator) {\n        throw new ReferenceError('Invalid value of `--identifier-names-generator` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const ObfuscationTargetSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectTarget: boolean = Object\n        .keys(ObfuscationTarget)\n        .some((key: string): boolean => {\n            return ObfuscationTarget[<keyof typeof ObfuscationTarget>key] === value;\n        });\n\n    if (!isCorrectTarget) {\n        throw new ReferenceError('Invalid value of `--target` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const SourceMapModeSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectSourceMapMode: boolean = Object\n        .keys(SourceMapMode)\n        .some((key: string): boolean => {\n            return SourceMapMode[<keyof typeof SourceMapMode>key] === value;\n        });\n\n    if (!isCorrectSourceMapMode) {\n        throw new ReferenceError('Invalid value of `--source-map-mode` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\nimport { TStringArrayEncoding } from '../../types/options/TStringArrayEncoding';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {string} value\n * @returns {TStringArrayEncoding}\n */\nexport const StringArrayEncodingSanitizer: TCLISanitizer <TStringArrayEncoding> = (value: string): TStringArrayEncoding => {\n    switch (value) {\n        case 'true':\n        case '1':\n        case StringArrayEncoding.Base64:\n            return true;\n\n        case StringArrayEncoding.Rc4:\n            return StringArrayEncoding.Rc4;\n\n        default:\n            return false;\n    }\n};\n","import * as fs from 'fs';\nimport * as mkdirp from 'mkdirp';\nimport * as path from 'path';\n\nimport { TObject } from '../../types/TObject';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\n\nexport class CLIUtils {\n    /**\n     * @param {string} inputPath\n     * @returns {string}\n     */\n    public static getOutputCodePath (inputPath: string): string {\n        return path\n            .normalize(inputPath)\n            .split('.')\n            .map((value: string, index: number) => {\n                return index === 0 ? `${value}${JavaScriptObfuscatorCLI.obfuscatedFilePrefix}` : value;\n            })\n            .join('.');\n    }\n\n    /**\n     * @param {string} outputCodePath\n     * @param {string} sourceMapFileName\n     * @returns {string}\n     */\n    public static getOutputSourceMapPath (outputCodePath: string, sourceMapFileName: string = ''): string {\n        if (sourceMapFileName) {\n            outputCodePath = `${outputCodePath.substring(\n                0, outputCodePath.lastIndexOf('/')\n            )}/${sourceMapFileName}`;\n        }\n\n        if (!/\\.js\\.map$/.test(outputCodePath)) {\n            outputCodePath = `${outputCodePath.split('.')[0]}.js.map`;\n        } else if (/\\.js$/.test(outputCodePath)) {\n            outputCodePath += '.map';\n        }\n\n        return outputCodePath;\n    }\n\n    /**\n     * @param {string} configPath\n     * @returns {TObject}\n     */\n    public static getUserConfig (configPath: string): TObject {\n        let config: TObject;\n\n        try {\n            config = require(configPath);\n        } catch {\n            try {\n                config = __non_webpack_require__(configPath);\n            } catch {\n                throw new ReferenceError('Given config path must be a valid `.js` or `.json` file path');\n            }\n        }\n\n        return config;\n    }\n\n    /**\n     * @param {string} outputPath\n     * @param {string} data\n     */\n    public static writeFile (outputPath: string, data: string): void {\n        mkdirp.sync(path.dirname(outputPath));\n\n        fs.writeFileSync(outputPath, data, {\n            encoding: JavaScriptObfuscatorCLI.encoding\n        });\n    }\n}\n","module.exports = require(\"mkdirp\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 214;","import * as fs from 'fs';\nimport * as path from 'path';\nimport multimatch from 'multimatch';\n\nimport { TInputCLIOptions } from '../../types/options/TInputCLIOptions';\nimport { TSourceCodeData } from '../../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../../interfaces/cli/IFileData';\n\nimport { LoggingPrefix } from '../../enums/logger/LoggingPrefix';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\nimport { Logger } from '../../logger/Logger';\n\nexport class SourceCodeReader {\n    /**\n     * @type {string[]}\n     */\n    public static readonly availableInputExtensions: string[] = [\n        '.js'\n    ];\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    private readonly options: TInputCLIOptions;\n\n    /**\n     * @param {TInputCLIOptions} options\n     */\n    constructor (options: TInputCLIOptions) {\n        this.options = options;\n    }\n\n    /**\n     * @param {string} filePath\n     * @param {string[]} excludePatterns\n     * @returns {boolean}\n     */\n    private static isExcludedPath (filePath: string, excludePatterns: string[] = []): boolean {\n        if (!excludePatterns.length) {\n            return false;\n        }\n\n        const fileName: string = path.basename(filePath);\n        const isExcludedFilePathByGlobPattern: boolean = !!multimatch([filePath], excludePatterns).length;\n        const isExcludedFilePathByInclusion: boolean = excludePatterns.some((excludePattern: string) =>\n            filePath.includes(excludePattern) || fileName.includes(excludePattern)\n        );\n\n        return isExcludedFilePathByInclusion || isExcludedFilePathByGlobPattern;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isDirectoryPath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isDirectory();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isFilePath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isFile();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     */\n    private static logFilePath (filePath: string): void {\n        const normalizedFilePath: string = path.normalize(filePath);\n\n        Logger.log(\n            Logger.colorInfo,\n            LoggingPrefix.CLI,\n            `Obfuscating file: ${normalizedFilePath}...`\n        );\n    }\n\n    /**\n     * @param {string} inputPath\n     * @returns {TSourceCodeData}\n     */\n    public readSourceCode (inputPath: string): TSourceCodeData {\n        if (SourceCodeReader.isFilePath(inputPath) && this.isValidFile(inputPath)) {\n            return this.readFile(inputPath);\n        }\n\n        if (SourceCodeReader.isDirectoryPath(inputPath) && this.isValidDirectory(inputPath)) {\n            return this.readDirectoryRecursive(inputPath);\n        }\n\n        const availableFilePaths: string = SourceCodeReader\n            .availableInputExtensions\n            .map((extension: string) => `\\`${extension}\\``)\n            .join(', ');\n\n        throw new ReferenceError(`Given input path must be a valid ${availableFilePaths} file or directory path`);\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @param {IFileData[]} fileData\n     * @returns {IFileData[]}\n     */\n    private readDirectoryRecursive (directoryPath: string, fileData: IFileData[] = []): IFileData[] {\n        fs.readdirSync(directoryPath, JavaScriptObfuscatorCLI.encoding)\n            .forEach((fileName: string) => {\n                const filePath: string = `${directoryPath}/${fileName}`;\n\n                if (SourceCodeReader.isDirectoryPath(filePath) && this.isValidDirectory(filePath)) {\n                    fileData.push(...this.readDirectoryRecursive(filePath));\n                } else if (SourceCodeReader.isFilePath(filePath) && this.isValidFile(filePath)) {\n                    const content: string = this.readFile(filePath);\n\n                    fileData.push({ filePath, content });\n                }\n            });\n\n        return fileData;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {string}\n     */\n    private readFile (filePath: string): string {\n        SourceCodeReader.logFilePath(filePath);\n\n        return fs.readFileSync(filePath, JavaScriptObfuscatorCLI.encoding);\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @returns {boolean}\n     */\n    private isValidDirectory (directoryPath: string): boolean {\n        return !SourceCodeReader.isExcludedPath(directoryPath, this.options.exclude);\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private isValidFile (filePath: string): boolean {\n        return SourceCodeReader.availableInputExtensions.includes(path.extname(filePath))\n            && !filePath.includes(JavaScriptObfuscatorCLI.obfuscatedFilePrefix)\n            && !SourceCodeReader.isExcludedPath(filePath, this.options.exclude);\n    }\n}\n","module.exports = require(\"multimatch\");"],"sourceRoot":""}